1. Операционные системы: определение, назначение, состав (**НЕ НАПИСАЛ**), функции.
	- Операционная система — это комплект программ, которые служат интерфейсом между модулями вычислительных систем и прикладными программными приложениями, а также управляют компьютерным оборудованием и процессами вычислений, эффективным распределением вычислительных мощностей среди процессов вычислений
	- ОС управляет всеми устройствами компьютерной системы (процессорами, оперативной памятью, дисками, клавиатурой, монитором, принтерами, сетевыми устройствами и др.) и обеспечивает пользователя удобным интерфейсом для работы с аппаратурой.
	- Две основные функции (назначение) ОС:
		- предоставлять пользователю некую расширенную виртуальную машину, с которой легче работать (легче программировать), чем непосредственно с аппаратурой реального компьютера или реальной сети;
		- управлять ресурсами вычислительной системы.
	- Поэтому в специальной литературе ОС представляется всегда двояко: как расширенная виртуальная машина и как система управления ресурсами
	- Функции ОС автономного компьютера обычно группируются в соответствии с типами локальных ресурсов, которыми управляет ОС. Такие группы называют подсистемами. Наиболее важные из них:
		- подсистема управления процессами,
		- подсистема управления памятью,
		- подсистема управления файлами,
		- подсистема управления внешними устройствами,
		- подсистема пользовательского интерфейса,
		- подсистема защиты данных и администрирования
	- Функции ОС:
		- прием от пользователя (оператора) заданий или команд, сформулированных на соответствующих языках, и их обработка;
		- загрузка в ОП программ и их исполнение;инициация программы (передача ей управления);
		- прием и исполнение программных запросов на запуск, приостановку, остановку других программ; организация взаимодействия между задачами;
		- идентификация всех программ и данных;
		- обеспечение работы системы управления файлами и/или систем управления БД;
		- обеспечение режима мультипрограммирования (многозадачности);
		- планирование и диспетчеризация задач;
		- обеспечение функций по организации и управлению операциями ввода/вывода;
		- удовлетворение жестким ограничениям на время ответа в режиме реального времени (для соответствующих ОС);
		- управление памятью, организация виртуальной памяти;
		- организация механизмов обмена сообщениями и данными между выполняющимися программами;
		- защита одной программы от влияния другой; обеспечение сохранности данных;
		- аутентификация, авторизация и другие средства обеспечения безопасности;
		- предоставление услуг на случай частичного сбоя системы;
		- обеспечение работы систем программирования;
		- параллельное исполнение нескольких задач.
2. Операционные системы: классификация, основные этапы развития, особенности современного этапа развития
	- Классификация
		- В зависимости от способа организации вычислений:
			- Системы пакетной обработки – основной задачей является организация наибольшего количества вычислительных процессов за единицу времени.
			Определенные процессы объединяются в пакет, который затем обрабатывает ОС.
			- Системы разделения времени – создание возможности единовременного взаимодействия с устройством сразу несколькими людьми. В порядке очереди каждый пользователь получает определенный промежуток процессорного времени.
			- Системы реального времени – организация работы каждой задачи за определенный промежуток времени, присущий каждой конкретной задаче.
		- В зависимости от типа ядра:
			- OС с монолитным ядром;
			- OС с микроядром;
			- OС с гибридным ядром.
		- В зависимости от количества единовременно решаемых задач:
			- однозадачные;
			- многозадачные;
		- В зависимости от количества пользователей:
			- однопользовательские;
			- многопользовательские.
		- В зависимости от количества поддерживаемых процессоров:
			- однопроцессорные
			- многопроцессорные
		- В зависимости от возможности работы в компьютерной сети:
			- локальные – автономные ОС, которые не позволяют работать с компьютерными сетями;
			- сетевые – ОС с поддержкой компьютерных сетей.
		- В зависимости от роли в сетевом взаимодействии:
			- серверные – ОС, открывающие доступ к ресурсам сети и осуществляющие управление сетевой инфраструктурой;
			- клиентские – ОС, которые имеют возможность получения доступа к ресурсам сети.
		- В зависимости от типа лицензии:
			- открытые – ОС с открытым исходным кодом, который можно изучать и редактировать;
			- проприетарные – ОС, связанные с определенным правообладателем и, как правило, имеющие закрытый исходный код.
	- Основные этапы развития
		- Первое (45-55гг)
			- программы в машинных кодах
			- загрузка программы в память вручную или с перфокарт
			- система выполняет одну операцию одновременно (последовательная обработка данных)
			- в самом конце появляется первое системное ПО
		- Второе (55-65гг)
			- использование небольших недорогих компьютеров для записи заданий на магнитную ленту вместо того, чтобы готовить задания непосредственно на больших машинах. Программа, считывающая задания с ленты и запускающая их на выполнение, является прообразом ОС
			- научные и технические вычисления
			- появление настоящих ОС (Fortran Monitor System, IBSYS)
			- разделение труда на операторов, разработчиков и специалистов по эксплуатации
		- Третье (65-80гг)
			- многозадачность (асинхронность)
			- подкачка данных ( способность считывать задание с перфокарт на диск по мере того, как их приносили в машинный зал. При окончании выполнения каждого текущего задания операционная система могла загружать новое задание с диска в освободившийся раздел памяти и запускать это задание)
			- режим разделения времени (вариант многозадачности, при котором у каждого пользователя есть свой диалоговый терминал)
		- Четвёртое (80-05гг)
			- персональные компьютеры
			- MS-DOS
			- сначала текстовый, затем графический интерфейс
			- распределённые операционные системы со свойством масштабируемости
		- Пятое (05-н.в.)
			- многоядерность
			- ОС для смартфонов
			- Android
			- виртуализация (предоставление вычислительных ресурсов, абстрагированное от аппаратной реализации (память, устройства ввода-вывода, ОС и т.д.), например, облачные технологии)
	- Особенности современного развития
		- На современном этапе развития операционных систем на передний план вышли средства обеспечения безопасности. Это связано с возросшей ценностью информации, обрабатываемой компьютерами, а также с повышенным уровнем угроз, существующих при передаче данных по сетям, особенно по публичным, таким как Интернет. Многие операционные системы обладают сегодня развитыми средствами защиты информации, основанными на шифрации данных, аутентификации и авторизации. Современным операционным системам присуща многоплатформенность, т.е. способность работать на совершенно различных типах компьютеров. В последние годы получила дальнейшее развитие долговременная тенденция повышения удобства работы человека с компьютером. Эффективность работы человека становится основным фактором, определяющим эффективность вычислительной системы в целом. Усилия человека не должны тратиться на настройку параметров вычислительного процесса, как это происходило в ОС предыдущих поколений. Постоянно повышается удобство интерактивной работы с компьютером путем включения в операционную систему развитых графических интерфейсов, использующих наряду с графикой звук и видеоизображение
3. Компоненты архитектуры вычислительных систем, их назначение и взаимодействие.
	- Классическая архитектура (фон Нейман)
		- Компоненты
			- АЛУ (арифметические и логические операции)
			- Управляющее устройство, выполняющее процесс выполнения программ
			- Внешнее запоминающее устройство для хранения программ и данных
			- ОЗУ
			- Устройство ввода-вывода информации
	- Шинная архитектура
		- Компоненты
			- **Контроллер** можно рассматривать как специализированный процессор, управляющий работой "вверенного ему" внешнего устройства по специальным встроенным программам обмена. Такой процессор имеет собственную систему команд. Например, контроллер на гибких магнитных дисках (дисковода) умеет позиционировать головку на нужную дорожку диска, читать или записывать сектор, форматировать дорожку и т.п. Результаты выполнения каждой операции заносятся во внутренние регистры памяти контроллера, которые могут быть в дальнейшем прочитаны центральным процессором накопителя
			- Для связи между отдельными функциональными узлами ЭВМ используется **общая шина**. Шина — это несколько проводников, соединяющих несколько устройств. Шины можно разделить на категории в соответствии с выполняемыми функциями. Они могут быть внутренними по отношению к процессору и служить для передачи данных в АЛУ и из АЛУ, а могут быть внешними по отношению к процессору и связывать процессор с памятью или устройствами ввода-вывода
				- Шина данных. По этой шине данные передаются между различными устройствами. Разрядность шины данных определяется разрядностью процессора, т. е. количеством двоичных разрядов, которые процессор обрабатывает за один такт. Со времени создания первого персонального компьютера (1975 г.), разрядность шины данных увеличилась с 8 до 64 бит.
				- Шина адреса. Каждая ячейка оперативной памяти имеет свой адрес. Адрес передается по адресной шине. Разрядность шины адреса определяет адресное пространство процессора, т. е. количество ячеек оперативной памяти, которые могут иметь уникальные адреса. Количество адресуемых ячеек памяти равно 2^n^, где n – разрядность шины адреса. В первых персональных компьютерах разрядность шины адреса составляла 16 бит, в современных персональных компьютерах разрядность шины адреса составляет 64 бита.
				- Шина управления. По шине управления передаются сигналы, определяющие характер обмена информацией по магистрали. Сигналы управления определяют, какую операцию - считывание или запись информации из памяти — нужно производить, синхронизируют обмен информацией между устройствами и т. д.
  			- **Процессор** - "мозг" компьютера. Выбирает команды из ОЗУ и выполняет их. Цикл выплнения: выборка первой команды, декодирование, выполнение до тех пор, пока программа не кончится.
      			Специальные регистры:
				- счётчик команд (адрес следующей команды)
				- адрес вершины стека
				- слово состояния программы (хрен знает, что это такое, но в него входит бит, указывающий, в каком режиме работает программа (пользовательский или ядра))
        		От простого цикла извлечения команд по одной давно отказались, теперь используют **конвейер** - исполнение нескольких команд одновременно. Процессоры с суперскалярной архитектурой имют несколько исполнительных блоков, котооые могут исполнять команды не в порядке следования
				Два режима:
            	- ядра (все команды)
            	- пользовательский (ограниченное множество команд и возможностей)
            	Архитектуры процессоров:
				- CISC (Complex Instruction Set Computer): использование сложных инструкций процессора, выполняющих много действий, написанных на микрокоде (простых командах) и хранящихся в readonly памяти. Микрокод очень сложно отлаживать, нельзя нормально ковейеризировать, потому что инструкции разные по длине выполнения, а пока не декодируешь - не поймёшь, что за инструкция, жрёт больше энергии. Но зато писать ассемблерный код для CISC-процессора быстрее, проще и приятнее
				- RISC (Reduced...): использование нескольких простых команд вместо одной сложной (и вот мы снова тут), т.к. большинство сложных инструкций почти не используются, и можно не заниматься отладкой микрокода. Она оптимизирована для компиляторов, а не для людей. Использует конвейеризацию: разделение инструкций на этапы, каждый из которых выполняется приблизительно одинаково по времени. Пять этапов:
    				- Извлечение команды из памяти и увеличение счётчика команд
    				- Декодирование
    				- Выполнение
    				- Доступ к памяти, если это необходимо
    				- Запись результатов в нужный регистр
  				- RISC-V (Five): открытая, бесплатная, включает в себя небольшой фиксированный набор команд с модульными фиксированными стандартными расширениями. Гибкая, поддерживает инновации (производитель может просто добавить свой модуль команд), снижение затрат и ускорение выхода на рынок
    		- Память
        		- используется иерархия уровней, потому что память физически не может быть и быстрой, и объёмной, и дешёвой
            		- регистры (не уступают в быстродействии процессору)
            		- кеш (обычно делится на кеш-строки по 64 байта)
            		- основная память
            		- магнитный диск
            		- магнитная лента
      		- Шины PCI и PCIe
    			- Первая старше (очевидно) и состоит из собственно шины, к которой подключается вся периферия и мост, соединящий процессор и память (они к шине непосредственно не подключены)
    			- Вторая имеет корневой комплекс вместо моста. У него есть порты, к которым подключаются коммутаторы PCIe, соединяющие несколько устройств PCIe, либо просто устройства PCIe, либо мост PCI, соединяющий корневой комплекс с шиной PCI. Соединения между устрйоствами последовательные и 1-битные вместо 8, 16, 32 и 64-битных у PCI. Какми-то образом это увеличивает пропускную способность. Все взаимодействия являются одноранговыми. Когда процессор хочет обратиться к устройству, он отправляет этому устройству пакет и обычно получает ответ. Пакет проходит через корневой комплекс на материнской плате, а затем передается устройству — как правило, через коммутатор
  			- Шина USB
  			- Видеокарты (устройство, преобразующее цифровую информацию в форму, пригодную для дальнейшего вывода на экран монитора). Может иметь свой графический процессор, снимая эту задачу с ЦП. АПИ для программирования графических приложений:
    			- Direct3D
    			- OpenGL
    			- Vulkan
4. Задачи операционной системы по управлению и организации работы компьютера.
	- Группы функций
    	- Виртуальная память. Механизм виртуальной памяти используется многими операционными системами. Она позволяет создать впечатление, будто у машины больше памяти, чем есть на самом деле.
    	- Файловый ввод-вывод. Это понятие более высокого уровня, чем команды вводавывода, которые мы рассматривали в предыдущей главе.
    	- Параллелизм (как организовано одновременное выполнение нескольких процессов, обмен информацией и синхронизация)
  	- Более подробно
    	- Параллельное функционирование модулей ввода (работающих с блоками, имеющими фиксированный размер и свой адрес (например, жёсткие диски) или байтами (не поддерживают адресацию и поиск информации) (например, сетевые адаптеры)), вывода информации и процессора.
    	- Организация кэширования данных и выполнение согласования скоростей информационного обмена.
    	- Разбиение модулей и информационных данных среди процессов.
    	- Организация удобной работы логического интерфейса между модулями и оставшейся частью системы.
    	- Организация поддержки различных устройств с обеспечением возможности просто их добавить.
    	- Режим динамической загрузки и выгрузки драйверов.
    	- Обеспечение поддержки набора файловых систем.
  	- Главным принципом построения программного обеспечения ввода и вывода информации является разбиение его на отдельные уровни. При этом нижние уровни должны обеспечивать защиту особенностей своего оборудования от влияния верхних уровней, которые призваны только осуществлять удобное интерфейсное обслуживание пользователей. Ещё одним базовым вопросом в организации программ информационного ввода и вывода считается обработка ошибок. Общеизвестно, что обработку ошибок нужно осуществлять максимально близко к оборудованию. Когда контроллер находит ошибку чтения, то ему необходимо сделать попытку её коррекции. Если эта попытка окажется неудачной, то дальше коррекцией ошибки занимается драйвер модуля. Часто ошибки пропадают при повторном выполнении операции ввода или вывода информации. Но когда ликвидацию ошибки не удалось выполнить на нижнем уровне, идёт сообщение об ошибке на верхний уровень
  	- Программное обеспечение ввода и вывода информации делится на следующие уровни:
    	- Уровень обработки прерываний.
    	- Уровень драйверов оборудования
    	- Уровень независимого от оборудования слоя операционной системы.
    	- Пользовательский уровень программного обеспечения
  	- Виртуализация -  технология, которая позволяет создавать несколько сред или выделенных ресурсов из единой физической аппаратной системы. Программное обеспечение, гипервизор, напрямую подключается к этой аппаратной системе и позволяет разбить ее на отдельные, безопасные среды – виртуальные машины. По идее, гипервизор должен распределять аппаратные ресурсы между виртуальными машинами так, чтобы процессы выполнялись быстрее. Физическая машина с гипервизором называется хостом, а виртуальные машины, которые используют ресурсы данного хоста – гостями
5. Структура ядра и его функции. Объекты ядра. Основные операции над объектами ядра. 
    - Структура ядра и его функции
        - Ядро — низкоуровневая основа любой операционной системы, выполняемая аппаратурой в особом привилегированном режиме. Ядро загружается в память один раз и находится в памяти резидентно (постоянно), по одним и тем же адресам. Обеспечивает архитектуру связи с приложениями, организует и регулирует доступ к ресурсам компьютера.
     	- Под архитектурой ОС обычно понимают структурную организацию ОС на основе программных модулей
     	- Обобщённая структура ОС состоит из ядра, окружённого системными услугами, поддержкой сети, работой с устройствами, системой разработки программ, работой с пользователями, приложениями.
     	- Ядро является модулями, выполняющими основные функции ОС:
         	- управление памятью
         	- управление процессами
         	- управление устройствами ввода-вывода
     	- Функции, входящие в состав ядра
         	- внутрисистемные (недоступные для приложений)
         	- апи (обслуживают системные вызовы, предоставляют доступ к системным ресурсам в удобной форме)
       	- Функции модулей ядра — наиболее часто используемые функции ОС, скорость их выполнения определяет производительность всей системы в целом
       	- Остальные модули выполняют полезные, но менее значимые функции:
         	- утилиты — программы, которые решают отдельные задачи управления и сопровождения компьютерной системы (сжатие, дефрагментация …);
         	- библиотеки процедур и функций различного назначения (библиотека математических функций, библиотека функций ввода-вывода и т.д.);
         	- программы предоставления пользователю дополнительных услуг — специальный вариант пользовательского интерфейса, калькулятор, некоторые игры (какие, например, поставляются в составе ОС);
         	- системные обрабатывающие программы — текстовые и графические редакторы, компиляторы, компоновщики, отладчики
       	- Задачи, выполняемые ядром
         	- обработка прерываний
         	- формирование и ликвидация процессов
         	- переключение состояний и диспетчеризация процессов
         	- синхронизация и обмен данными между процессами
         	- ввод и вывод
         	- распределение ресурсов
         	- поддержка файловых систем
       	- Подсистемы
         	- управления процессами (выполняет также распределениесистемных ресурсов между процессами)
         	- управления памятью (оперативной; распределяет память процессам, выгружает их в файл подкачки)
         	- файловая (обеспечивает унифицированный доступ к данным (например, чтобы использование одних и тех же функций выдавало одинаковый результат для файлов, принтеров и терминалов))
         	- ввода-вывода (выполняет запросы файловой подсистемы и подсистемы управления процессами на доступ к периферии. Взаимодействует с программами ядра)
       	- Виды ядер
         	- монолит (по сути, это просто большой набор сервисных функций. Формируется из обширного комплекта абстракций  борудования. Все элементы монолитного ядра работают в едином адресном формате. При такой организации операционной системы все составляющие части её ядра выступают как элементы основной программы, применяют одни и те же системы организации данных и работают друг с другом, используя непосредственный вызов процедуры)
         	- модульная (современная, не требует реструктуризации для разного аппаратного обечпечения, может подгружать разные модули как на лету, так и при переконфигурировании и перезагрузке системы. Но так как все модули работают в режиме ядра, то сбой в одном из них потянет за собой всё ядро, и надо будет перезагружать ОС)
         	- микро (решает небольшой набор задач и имеет небольшой набор абстракций. Главный признак - распределение практически всех драйверов и элементов в процессах сервиса)
         	- экзо (предоставляет только возможность взаимного обмена между процессами и надёжного распределения и высвобождения ресурсов. Распределяет ресурсы между виртуальными машинами и следит, чтобы ни одна из них не лезла в чужие ресурсы)
         	- нано (решает лишь проблему аппаратных прерываний, генерируемых разными блоками компьютера. Передаёт результаты вышестоящей по рангу программе при помощи прерываний)
         	- гибридная (ускоренная модификация микроядра)
         	- комбинированная (коктейль из всего вышеперечисленного)
  	- Объекты ядра
    	- Используются системой и приложениями для управления множеством разных ресурсов (процессов, потоков). Приложения не могут обращаться к ним напрямую. На самом деле это просто блоки памяти, выделенные ядром и доступные только ему. Блок представляет собой структуру данных, в элементах которой содержится информация об объекте. Некоторые элементы (дескриптор защиты, счетчик числа пользователей и др.) присутствуют во всех объектах, но большая их часть специфична для объектов конкретного типа.
    	- **Объект** — это коллекция данных, являющихся частью режима ядра операционной системы, которыми управляет Диспетчер объектов Windows
    	- Категории
        	- устройств
        	- файлов
        	- символические ссылки
        	- разделы реестра
        	- потоки и процессы
        	- диспетчера ядра (события, мьютексы...)
        	- обратного вызова
        	- объекты section
      	- Взаимодествие программ с объектами подчиняется строгим правилам. Когда мы создаем объект ядра в операционной системе Windows, функция возвращает описатель, идентифицирующий созданный объект (HANDLE). Все операции с текущим объектом ядра возможны только при передаче этого описателя управляющей функции. При этом использовать один описатель в разных процессах (за одним исключением) низя.
      	- Объекты принадлежат ядру, а не процессу. Завершив создавший его процесс, объект не разрушится, пока есть другие процессы, использующие его. При этом используется счётчик, присваиваемый объекту ядром (+1 или -1, всё такое)
  	- Основные операции над объектами ядра
    	- Система позволяет динамически создавать новые типы объектов. В этом случае предполагается регистрация его методов у диспетчера объектов
    	- Для работы с объектами есть функции фреймворка ОС (CreateFile, OpenMutex...). Это библиотечные процедуры, за которыми стоят сервисы Windows и методы объектов
    	- Функция CreateFile, несмотря на первое впечатление от ее имени, используется и при работе с уже существующими файлами, так как слово File здесь обозначает не файл на диске, а объект ядра типа File
    	- Некоторые объекты ядра имеют разрешение Synchronize. Это означает, что их можно использовать как для синхронизации потоков
6. Утилиты. Системные обрабатывающие программы. Библиотеки процедур. Программы дополнительных услуг. 
	- Утилиты
    	- Системное программное обеспечение, которое помогает поддерживать правильное и бесперебойное функционирование компьютерной системы. Они помогают операционной системе управлять, организовывать, поддерживать и оптимизировать функционирование компьютерной системы
    	- Типы
        	- Антивирусы
        	- Системы управления файлами
        	- Инструменты сжатия
        	- Инструменты управления дисками (например, разбиение на разделы)
        	- Инструменты очистки диска
        	- Дефрагментация диска
        	- Резервного копирования
	- Системные обрабатывающие команды
    	- Обрабатывающие системные программы отличаются от управляющих программ как по своим функциям, так и по способу их инициирования (запуска) (каво?)
    	- Функции и тип устройства в зависимости от преобладающей функции:
        	- Перенос информации (между устройствами или в пределах одного устройства) (утилита)
        	- Преобразование информации (после считывания преобразует и лишь затем записывает её дальше) (лингвистический процессор, основная функция которого - перевод описания алгоритма с одного языка на другой (с человеческого на машинный))
            	- транслятор (выдаёт целиком)
                	- компилятор (программа на высоком уровне)
                	- ассемблер (программа на языке ассемблера (какой ужас, что это вообще?))
            	- интерпретатор (выдаёт постепенно), например, PowerShell
	- Библиотеки процедур
        - Библиотеки процедур и функций различного назначения включены в категорию вспомогательных модулей операционной системы. К ним можно отнести библиотеки математических функций, библиотеки функций ввода-вывода и т.д.
        - Библиотеки — это набор функций, которые могут использоваться в различных программах.
            - Статические
            - Динамические
        - Расположение системных библиотек
            - шиндовс: System32, System64
            - linux: /lib, /usr/lib
	- Программы дополнительных услуг
    	- В эту категорию входит большое количество разнообразных программ: специальный вариант пользовательского интерфейса, калькулятор, некоторые игры (какие, например, поставляются в составе ОС)
7. Понятие процесса. Системные и пользовательские процессы. Операции над процессами. 
8. Организация межпроцессного взаимодействия в ОС. Сигналы. Каналы. Классические проблемы межпроцессного взаимодействия.
	- Организация межпроцессного взаимодействия в ОС
      	- Взаимоисключение - проблема, когда каждый процесс, обращающийся к разделяемым данным, исключает для всех других процессов возможность одновременного с ним обращения к этим данным
      	- Уровни IPC
          	- локальный (очевидно, только на локальном компьютере): каналы, разделяемая память, очереди сообщений
          	- удалённый (очевидно, через сеть)
          	- высокоуровневый (обычно подразумеваются пакеты ПО, реализующего промежуточный слой между системной платформой и приложением)
      	- Методы
          	- Сигнал
          	- Файл
          	- Сокет
          	- Канал
          	- Именованный канал
          	- Семафор
          	- Разделяемая память
          	- Обмен сообщениями (без разделения)
          	- File mapping
          	- Очередь сообщений
          	- Почтовый ящик
  	- Сигналы
    	- Сигнал в операционных системах семейства Unix — асинхронное уведомление процесса о каком-либо событии, один из основных способов взаимодействия между процессами. Когда сигнал послан процессу, операционная система прерывает выполнение процесса, при этом, если процесс установил собственный обработчик сигнала, операционная система запускает этот обработчик, передав ему информацию о сигнале, если процесс не установил обработчик, то выполняется обработчик по умолчанию
    	- Классы
        	- системные
        	- от устройств
        	- пользовательские
      	- Части механизма передачи сигналов
        	- установление и обозначение сигналов в виде целочисленных значений
        	- маркер в строке таблицы процессов для прибывших сигналов
        	- таблица с адресами функций, определяющих реакцию на прибывшие сигналы
      	- Как только сигнал приходит, он отмечается записью в таблице процессов. Если этот сигнал предназначен для процесса, то по таблице указателей функций в структуре описания процесса выясняется, как нужно реагировать на этот сигнал. При этом номер сигнала служит индексом таблицы
      	- Варианты реакции на сигнал
        	- вызов собственной функции-обработчика
        	- игнор
        	- использование прдустановленного обработчика
      	- Можно пожалуйста я не буду копипастить все 24 сигнала из таблички? Есть сигнал SIGKILL, он завершает программу
  	- Каналы
    	- Канал (pipe) представляет собой средство связи стандартного вывода одного процесса со стандартным вводом другого. Каналы старейший из инструментов IPC, существующий приблизительно со времени появления самых ранних версий оперативной системы UNIX. Для реализации IPC возможно использование полудуплексных и/или именованных каналов (FIFO)
    	- Для создания канала используется системный вызов pipe(). Его формат следующий:
			```
			#include <inistd.h>
			int pipe (int fd[2]);
			```
		- Аргументом функции является указатель на массив двух целых чисел, в котором функция возвращает два файловых дескриптора. Первый из них предназначен для чтения данных из канала, второй - для записи в него. Читать и писать в канал можно при помощи ```read()``` и ```write()```
  	- Классические проблемы
    	- Синхронный доступ. Если все процессы считывают данные из файла, то в большинстве случае проблем не возникает. Однако, при попытке одним из процессов изменить этот файл, могут возникнуть так называемые конкурентные ситуации (race conditions).
    	- Дисциплина доступа. Если нужно, чтобы как можно большее количество пользователей могли записывать данные, организуется так называемая очередь (по правилу «один пишет, несколько читают»). Практически организуется две очереди: одна — для чтения, другая — для записи. Такую дисциплину доступа можно организовать с помощью барьеров (блокировок). При этом создается общий барьер для считывателей, так как несколько процессов могут одновременно считывать данные, а также отдельный барьер для процесса-писателя. Такая организация предотвращает взаимные помехи в работе.
    	- Голодание процессов. Организация дисциплины доступа может привести к ситуации, когда процесс будет длительно ждать своей очереди для записи данных. Поэтому иногда нужно организовывать очереди с приоритетами
    	- Управление потоком. Если нельзя точно определить, какой из процессов запрашивает или возвращает свои данные в нужный компьютер первым, используется так называемое взаимодействие по модели "клиент-сервер". При этом используются один или несколько клиентов и один сервер. Клиент посылает запрос серверу, а сервер отвечает на него. После этого клиент должен дождаться ответа сервера, чтобы продолжать дальнейшее взаимодействие
    	- Тупик (deadlock). Не маленькие, и так это знаете
    	- Там ещё две задачи: про философов и читателей с писателями, но я их сюда копировать не буду
9.  Концепция потока. Параллельное исполнение потоков. Главный поток процесса. 
10. Диаграммы состояния потоков. Понятие контекста и переключения контекста.
	- Диаграммы состояния потоков
    	- Состояния:
        	- выполнения (выполняется процессором)
        	- готовности к выполнению (готов и ждёт выделения процессорного времени)
        	- ожидания наступления некоторого события (не претендует на процессорное время)
      	- Переходы (только неочевидные)
        	- выполнения -> готовности
            	- при окончании кванта процессорного времени
            	- при появлении более приоритетного потока
          	- ожидание -> готовность
            	- в системе происходит какое-то событие, наступление готорого ожидает поток
          	- также поток может просто аварийно завершиться
  	- Понятие контекста и переключение контекста
    	- Переключение контекста — в многозадачных ОС и средах — процесс прекращения выполнения процессором одной задачи (процесса, потока, нити) с сохранением всей необходимой информации и состояния, необходимых для последующего продолжения с прерванного места, и восстановления и загрузки состояния задачи, к выполнению которой переходит процессор
    	- Сохраняемая информация
        	- регистры общего назначения
        	- контекст состояния сопроцессора с плавающей точкой
        	- регистры SSE, AVX (x86)
        	- сегментные регистры (x86) (речь идёт о сегментах кода, данных и т.д.)
        	- некоторые управляющие регистры
      	- Структуры ядра ОС, связанные с каждым потоком
        	- общая информация (pid, tid, ...)
        	- состояние процесса/потока
        	- права доступа
        	- используемые ресурсы и блокировки
        	- счётчики использованных ресурсов (например, таймер процессорного времени)
        	- память процесса
      	- Очень важно, при переключении контекста происходит
        	- очистка конвейера команд и данных процессора
        	- Очищается TLB (translation lookaside buffer), отвечающий за страничное отображение линейных адресов на физические
      	- Типы переключения контекста
        	- добровольное (поток сам решил приостановиться)
        	- принудительное
            	- ядро может отобрать управление, потому что кончился квант времени
            	- выполнение блокирующего системного вызова, и ядро решает, что может отобрать управление
            	- использование синхронизирующих примитивов ядра
            	- явная приостановка при помощи системного вызова (sleep, wait, ...)
11. Многозадачность в ОС. Типы многозадачности. 
12. Иерархия, приоритеты и планирование потоков. Динамические уровни приоритетов. 
	- Иерархия и приоритеты потоков:
        - Иерархия: Потоки часто группируются по уровням приоритета в зависимости от их важности и роли. Например, системные потоки могут иметь более высокий приоритет по сравнению с прикладными.
        - Приоритеты: Каждому потоку присваивается приоритет, который определяет его относительную важность и влияет на решение о том, какие потоки будут выполнены в первую очередь.
    - Планирование потоков
        - «циклическое планирование»: Одним из самых старых, простых, справедливых и наиболее часто используемых считается алгоритм циклического планирования. Каждому процессу назначается определенный интервал времени, называемый его квантом, в течение которого ему предоставляется возможность выполнения. Если процесс к завершению кванта времени все еще выполняется, то ресурс центрального процессора у него отбирается и передается другому процессу. Разумеется, если процесс переходит в заблокированное состояние или завершает свою работу до истечения кванта времени, то переключение центрального процессора на другой процесс происходит именно в этот момент. Недостаток: Если частые переключения (квант - 4мс, а время переключения равно 1мс), то происходит уменьшение производительности.
        - «приоритетное планирование»: Основная идея проста: каждому процессу присваивается значение приоритетности и запускается тот процесс, который находится в состоянии готовности и имеет наивысший приоритет. Даже если у персонального компьютера один владелец, на нем могут выполняться несколько процессов разной степени важности. Например, фоновому процессу, отправляющему электронную почту, должен быть назначен более низкий приоритет, чем процессу, воспроизводящему на экране видеофильм в реальном времени. Чтобы предотвратить бесконечное выполнение высокоприоритетных процессов, планировщик должен понижать уровень приоритета текущего выполняемого процесса с каждым сигналом таймера (то есть с каждым его прерыванием). Если это действие приведет к тому, что его приоритет упадет ниже приоритета следующего по этому показателю процесса, произойдет переключение процессов. Можно выбрать и другую альтернативу: каждому процессу может быть выделен максимальный квант допустимого времени выполнения. Когда квант времени будет исчерпан, шанс запуска будет предоставлен другому процессу, имеющему наивысший приоритет.
        - «кооперативное планирование»: Это такой алгоритм планирования, при котором процесс получает столько процессорного времени, сколько он считает нужным. Таким образом, все процессы делят процессорное время, периодически передавая управление следующей задаче.
    - Динамические уровни приоритетов: Некоторые системы поддерживают динамическое изменение приоритетов в зависимости от активности и состояния потоков. Например, при потреблении процессорного времени поток может повысить свой приоритет для более частого выполнения. Цель планирования потоков вполне очевидна — определение порядка выполнения потоков в условиях внешней или внутренней многозадачности. Однако способы достижения этой цели существенно зависят от типа ОС. В Windows каждый поток обладает динамическим приоритетом, который система может автоматически изменять для обеспечения отзывчивости и предотвращения голодания потоков. Динамический приоритет изначально совпадает с базовым приоритетом, и его система может повышать или понижать в зависимости от различных условий. Повышение приоритета происходит, например, при перемещении процесса на передний план, получении входных данных или выполнении условий ожидания. После повышения динамического приоритета система постепенно его уменьшает с течением времени. Этот механизм направлен на предотвращение инверсии приоритета и гарантирование эффективного использования процессорного времени
13. Синхронизация и взаимоблокировка ресурсов. Механизмы синхронизации.
14. Взаимоблокировка ресурсов в многозадачных системах. Решение задачи взаимоблокировки ресурсов. 
	- Взаимоблокировка в группе процессов возникает в том случае, если каждый процесс из этой группы ожидает события, наступление которого зависит исключительно от другого процесса из этой же группы. для возникновения ресурсных взаимоблокировок должны выполняться четыре условия: 
        1. Условие взаимного исключения. Каждый ресурс либо выделен в данный момент только одному процессу, либо доступен. 
        2.  Условие удержания и ожидания. Процессы, удерживающие в данный момент ранее выделенные им ресурсы, могут запрашивать новые ресурсы. 
        3.  Условие невыгружаемости. Ранее выделенные ресурсы не могут быть принудительно отобраны у процесса. Они должны быть явным образом высвобождены тем процессом, который их удерживает. 
        4.  Условие циклического ожидания. Должна существовать кольцевая последовательность из двух и более процессов, каждый из которых ожидает высвобождения ресурса, удерживаемого следующим членом последовательности.
	- Решение задачи взаимоблокировки ресурсов 
    	- Чаще всего для борьбы с взаимными блокировками используются четыре стратегии: 1. Игнорирование проблемы. Может быть, если вы проигнорируете ее, она проигнорирует вас.
    	- Обнаружение и восстановление. Дайте взаимоблокировкам проявить себя (не блокировать сразу же), обнаружьте их и выполните необходимые действия.
    	- Динамическое уклонение от них за счет тщательного распределения ресурсов.
    	- Предотвращение за счет структурного подавления одного из четырех условий, необходимых для их возникновения (одного из 4 которые описаны выше).
15. Компьютерное время. Ожидаемые таймеры.
16. Управление памятью: адресное пространство процесса, организация памяти, основные механизмы управления памятью, концепция рабочего множества. 
	- Адресное пространство процесса
    	- Адресное пространство — это набор адресов, который может быть использован процессом для обращения к памяти
    	- У каждого процесса имеется собственное адресное пространство, независимое от того адресного пространства, которое принадлежит другим процессам (за мааленькими исключениями)
    	- Адресное пространство процесса состоит из диапазона адресов, которые выделены процессу, и, что более важно, в этом диапазоне выделяются адреса, которые процесс может так или иначе использовать. Каждому процессу выделяется "плоское" 32- или 64-битовое адресное пространство. Термин "плоское" обозначает, что адресное пространство состоит из одного диапазона адресов (например, 32-разрядное адресное пространство занимает диапазон адресов от 0 до 429496729)
    	- Секции памяти
        	- код
        	- данные (инициализированные переменные)
        	- неинициализированные глобальные переменные
        	- стек процесса пространства пользователя (не путать со стеком процесса в пространстве ядра, который управляется и используется ядром)
        	- доп. сегменты каждой библиотеки, загружаемой в адресное пространство процесса
        	- все file mappingи
        	- все области совместно используемой памяти
        	- все анонимные отображения в память
	- Организация памяти
    	- Физические адреса — это реальные адреса, используемые для выбора микросхем физической памяти, содержащих данные. Физическая память организована в виде последовательности 8-разрядных байтов. Каждому байту присвоен уникальный адрес
    	- Модели доступа к памяти
        	- плоская
        	- сегментированная
        	- модель режима реального адреса
      	- ![модели доступа к памяти](модели_доступа_к_памяти.png)
	- Основные механизмы управления памятью
    	- Свопинг - процесс выгружается и загружается в ОЗУ полностью. Используются списки занятых и незанятых сегментов памяти
        	- первое подходящее (ищет первый подходящий незанятый сегмент нужного размера)
        	- следующее подходящее (то же самое, но при следующем поиске начинает искать оттуда, где остановился в прошлый раз, а не с самого начала)
        	- наиболее подходящее (ищет самый маленький сегмент из подходящих)
        	- наименее подходящее (ищет самый большой сегмент, чтобы наверняка)
        	- быстро искомое подходящее (использует отдельные списки для самых востребованных размеров сегментов)
      	- Виртуальная память - разбиение всей памяти на страницы фиксированного размера с непрерывным множеством адресов, выделение процессу памяти страницами
        	- Диспетчер памяти - аппаратный компонент компьютера, который обрабатывает все операции с памятью и кэшированием, связанные с процессором.
			Виртуальные адреса не выставляются напрямую на шине памяти. Вместо этого они поступают в диспетчер памятиВиртуальные адреса не выставляются напрямую на шине памяти. Вместо этого они поступают в диспетчер памяти, который отображает вирутальные адреса на реальные
			- Работа MMU
    			- аппаратное управление памятью (контроль и регуляция использования процессором ОЗУ и кеша)
    			- управление памятью ОС (обеспечение наличия достаточного количества памяти у процессов)
    			- управление памятью приложений (выделение памяти процессам и переиспользование её после того, как процесс завершается)
  			- Типы памяти
    			- Логическая (виртуальная)
    			- Физическая (реальная)
  			- Таблицы страниц используются для отображения виртуальных страниц на страничные блоки
    			- Запись состоит из номера страничного блока (вроде это реальный адрес страницы), бита присутствия/отсутствия (в реальной памяти), битов защиты (например, на чтение, запись, исполнение), бита изменения (имеет значение, когда ОС решает восстановить страницу. Если она не изменялась, то он страницы можно просто отказаться, потому что последняя версия и так лежит на диске) и бита ссылки (помогает ОС выбрать отселяемую страницу при возникновении ошибки отсутствия страницы. Если к странице не было обращений, её можно смело выкидывать).
  			- Буферы быстрого преобразования адреса (Translation Lookaside Buffer, TBA) используются для ускоренного доступа к часто используемым страницам и хранят их. Если при попытке найти нужную страницу в TLB её там нет, происходит поиск в обычной таблице страниц, и страница помещается в TLB
    			- Ошибки отсутствия записей
        			- программная (страница есть в памяти, но не в TLB, нужно просто обновить TLB)
        			- аппаратная (страницы нет ни в памяти, ни в TLB, ошибка обрабатывается в миллион раз медленнее программной)
  			- Таблицы страниц для больших объёмов памяти
    			- подход первый: многоуровневая таблица ![3.1.7](3.1.7.png)
    			- подход второй: инвертированные таблицы (одна запись для каждого страничного блока в реальной памяти, а не для каждой страницы в вируальном пространстве. Экономит много места, но сильно усложняет преобразование виртуальных адресов в реальные, потому что теперь нужно просматривать всю таблицу для поиска нужной страницы. Решается использованием TLB и хеш-таблиц)
	- Концепция рабочего множества
    	- Рабочий набор процесса — это набор страниц в виртуальном адресном пространстве процесса, которые в настоящее время находятся в физической памяти. Рабочий набор содержит только страничные выделения памяти. В рабочий набор не включаются ресурсы памяти, не допускающие подкачку, такие как расширения адресных окон (AWE) или большие страницы
    	- Если процесс ссылается на страницу памяти, которая в настоящее время не входит в рабочий набор, происходит ошибка страницы. Обработчик ошибки системной страницы пытается устранить ошибку страницы, и в случае успеха страница добавляется в рабочий набор
    	- Ошибка жесткой страницы должна быть устранена путем чтения содержимого страницы из резервного хранилища страницы, которое является системным файлом подкачки или файлом, сопоставленным в памяти, созданным процессом. Ошибка мягкой страницы может быть устранена без доступа к резервному хранилищу. Ошибка мягкой страницы возникает в следующих случаях:
        	- Страница находится в рабочем наборе какого-то другого процесса, поэтому она уже находится в памяти.
        	- Страница находится в состоянии перехода, так как она либо была удалена из рабочих наборов всех процессов, которые использовали страницу и еще не была перепрофилирована, либо она уже находится в результате операции предварительной выборки диспетчера памяти.
        	- Процесс впервые ссылается на выделенную виртуальную страницу (иногда это называется ошибкой с нулевым спросом)
    	- Страницы можно удалить из рабочего набора в следующих случаях:
        	- процесс уменьшает свой рабочий набор явно при помощи, например, SetWorkingSetSize
        	- процесс отменяет представление файла
        	- диспетчер памяти проводит обрезание рабочего набора
        	- диспетчер памяти должен заменить существующую страницу другой, например, из-за того, что текущий рабочий набор уже имеет максимальный размер
17. Классификация запоминающих устройств. Иерархия памяти. Оперативные и постоянные запоминающие устройства.
18. Виртуальная память. Структуризация адресного пространства виртуальной памяти. Задачи управления виртуальной памятью.
	- Виртуальная память
    	- Физические адреса являются конкретными и окончательными — без трансляции, без подкачки, без проверки привилегий. Вы выставляете их на шину и всё: выполняется чтение или запись. Однако в современной операционной системе программы используют абстракцию — виртуальное адресное пространство. Каждая программа пишется в такой модели, что она выполняется одна, всё пространство принадлежит ей, код использует адреса логической памяти, которые должны быть преобразованы в физические адреса до того, как будет выполнен доступ к памяти. Логический адрес на x86 состоит из двух частей: селектора сегмента и смещения внутри сегмента. Процесс трансляции включает два шага: 
        	- учёт сегментного селектора и переход от смещения внутри сегмента к некоторому линейному адресу;
        	- перевод линейного адреса в физический.
	- Структуризация адресного пространства виртуальной памяти
    	- Режимы адресации
        	- реальный (сначала вы устанавливаете сегментный регистр, по сути говоря «так, я хочу работать с куском памяти начиная с адреса X»; затем 16-битный адрес уже используется как смещение в рамках этого куска)
        	- защищённый (также используется сегментированная модель памяти, однако уже организованная по другому принципу: расположение сегментов описывается специальными структурами (таблицами дескрипторов), расположенными в оперативной памяти. Эти таблицы: глобальная и локальная (Global/Local Descriptor Table))
        	- длинный (нет сегментации, большинство сегментных регистров устанвливаются в 0, не используется таблица LDT, но используется GDT)
      	- Там что-то про кольца, но я его трубу шатал это переписывать, если честно
    	- Ставится задача транслировать 48-битный виртуальный адрес в физический. Она решается аппаратным обеспечением — блоком управления памятью (memory management unit, MMU). Этот блок является частью процессора. Чтобы транслировать адреса, он использует структуры данных в оперативной памяти, называемые таблицами страниц. Вместо двухуровневой системы таблиц страниц, используемой системами с 32-битной архитектурой x86, системы, работающие в длинном режиме, используют четыре уровня таблицы страниц
    	- Наиболее часто используемые размеры страниц:
        	- 4кб
        	- 2мб
        	- 1гб
      	- Пусть для определённости размер страницы равен 4 КБ. Значит, младшие 12 битов адреса кодируют смещение внутри страницы и не изменяются, а старшие биты используются для определения адреса начала страницы
	- Задачи управления виртуальной памятью
    	- размещает данные в запоминающих устройствах разного типа, например, часть программы в оперативной памяти, а часть на диске;
    	- перемещает по мере необходимости данные между запоминающими устройствами разного типа, например, подгружает нужную часть программы с диска в оперативную память;
    	- преобразует виртуальные адреса в физические.
    	- Операционные системы используют различные алгоритмы для определения, какие страницы данных должны быть выгружены из оперативной памяти, чтобы освободить место для других данных (LRU)
    	*Все эти действия выполняются автоматически*
19. Подкачка. Алгоритмы замещения страниц. Куча (heap). Стек.
20. Типы устройств ввода/вывода. Обработка внешних прерываний. Синхронный и асинхронный ввод/вывод. 
	- Типы устройств ввода-вывода
    	- К блочным относятся такие устройства, которые хранят информацию в блоках фиксированной длины, у каждого из которых есть собственный адрес. Вся передача данных ведется пакетами из одного или нескольких целых (последовательных) блоков. Важным свойством блочного устройства является то, что оно способно читать или записывать каждый блок независимо от всех других блоков. Среди наиболее распространенных блочных устройств жесткие диски, приводы оптических дисков и флеш-накопители USB.
    	- Другой тип устройств ввода-вывода — символьные устройства. Они выдают или воспринимают поток символов, не относящийся ни к какой блочной структуре. Они не являются адресуемыми и не имеют никакой операции позиционирования. В качестве символьных устройств могут рассматриваться терминалы, принтеры, сетевые интерфейсы, мыши (в качестве устройства-указателя) и множество других устройств, не похожих на дисковые устройства.
	- Обработка внешних прерываний
    	- На аппаратном уровне прерывания работают следующим образом. Когда устройство ввода-вывода заканчивает свою работу, оно инициирует прерывание (при условии, что прерывания разрешены операционной системой). Для этого устройство выставляет сигнал на выделенную устройству специальную линию шины. Этот сигнал распознается микросхемой контроллера прерываний, расположенной на материнской плате. Контроллер прерываний принимает решение о дальнейших действиях
    	- При отсутствии других необработанных запросов прерывания контроллер прерываний обрабатывает прерывание немедленно. Если прерывание уже обрабатывается, и в это время приходит запрос от другого устройства по линии с более низким приоритетом, то новый запрос просто игнорируется.
    	- Для обработки прерывания контроллер выставляет на адресную шину номер устройства, требующего к себе внимания, и устанавливает сигнал прерывания на соответствующий контакт процессора.
    	- Этот сигнал заставляет процессор приостановить текущую работу и начать выполнять обработку прерывания. Номер, выставленный на адресную шину, используется в качестве индекса в таблице, называемой вектором прерываний
    	- Вскоре после начала своей работы процедура обработки прерываний подтверждает получение прерывания, записывая определенное значение в порт контроллера прерываний. Это подтверждение разрешает контроллеру издавать новые прерывания. Благодаря тому, что центральный процессор откладывает выдачу подтверждения до момента, когда он уже готов к обработке нового прерывания, удается избежать ситуации состязаний при появлении почти одновременных прерываний от нескольких устройств
    	- Аппаратура всегда, прежде чем начать процедуру обработки прерывания, со-храняет определенную информацию. Сохраняемая информация и место ее хранения широко варьируются в зависимости от центрального процессора. Как минимум сохраняется счетчик команд, что позволяет продолжить выполнение прерванного процесса. Другая крайность представляет собой сохранение всех программно доступных регистров и большого количества внутренних регистров центрального процессора.
	- Синхронный и асинхронный ввод-вывод
    	- Асинхронный ввод-вывод (I/O) используется для оптимизации производительности приложений. В отличие от синхронного ввода-вывода, где приложение блокируется во время операции, асинхронный подход позволяет приложению продолжать выполнение, пока операция I/O выполняется.
    	- По умолчанию все файловые дескрипторы в Unix-системах создаются в «блокирующем» режиме.
    	- Существует два различных, но взаимодополняющих способа устранить блокировки:
        	- неблокирующий режим ввода-вывода
            	- Файловый дескриптор помещают в “неблокирующий” режим, добавляя флаг O_NONBLOCK к существующему набору флагов дескриптора с помощью fcntl:
					```
					/* Добавляем флаг O_NONBLOCK к дескриптору fd */ 
					const int flags = fcntl(fd, F_GETFL, 0); 
					fcntl(fd, F_SETFL, flags | O_NONBLOCK);
					```
				- С момента установки флага дескриптор становится неблокирующим
				- Недостатки: пустая трата процессорного времени
        	- мультиплексирование с помощью системного API, такого как select либо epoll
            	- Существует несколько мультиплексирующих системных вызовов:
                	- Вызов select существует во всех POSIX-совместимых системах, включая Linux и MacOSX
                	- Группа вызовов epoll_* существует только на Linux
                	- Группа вызовов kqueue существует на FreeBSD и других *BSD
              	- Все три варианта реализуют единый принцип: делегировать ядру задачу по отслеживанию прихода данных для операций чтения/записи над множеством файловых дескрипторов. Все варианты могут заблокировать выполнение, пока не произойдёт какого-либо события с одним из дескрипторов из указанного множества
              	- Все мультиплексирующие системные вызовы, как правило, работают независимо от режима файлового дескриптора (блокирующего или неблокирующего). Программист может даже все файловые дескрипторы оставить блокирующими, и после select либо epoll возвращённые ими дескрипторы не будут блокировать выполнение при вызове read или write, потому что данные в них уже готовы. 
21. Файловые системы. Файлы и директории. Управление внешней памятью. 
22. Принципы организации и структура ОС Windows. Обзор версий Windows. Методы инсталляции ОС Windows.
	- Принципы организации и структура Windows
    	- Архитектура шиндовс ![Архитектура](22.1.png)
        	- **Ядро операционной системы**. На самом низком уровне операционной системы ядро операционной системы состоит из самого ядра Windows и драйверов устройств низкого уровня. Ядро отвечает за прием запросов операционной системы от системных служб. Затем ядро преобразует эти запросы в инструкции для аппаратного обеспечения компьютера, включая центральный процессор (ЦП), память и аппаратные устройства. При запуске операционной системы сначала инициализируются ядро и связанные с ним низкоуровневые драйверы устройств, а затем службы операционной системы.
        	- **Системные службы**. Службы операционной системы являются частью операционной системы, а не компонентами, которые вы устанавливаете после развертывания операционной системы. Кроме того, службы операционной системы функционируют без каких-либо действий со стороны пользователя. Фактически они начинаются до того, как пользователь войдет в систему. И службы операционной системы, и драйверы устройств являются программным обеспечением. Однако разница между ними заключается в том, что драйверы устройств напрямую взаимодействуют с аппаратными устройствами или компонентами. Как правило, системная служба взаимодействует с другими программными компонентами операционной системы
        	- **Понимание приложений**. На верхнем уровне операционной системы приложения работают путем взаимодействия с пользователем компьютера, а на нижнем уровне — путем интеграции со службами операционной системы
        	- **Отличия службы от приложения**. Служба – процесс, работающий, даже когда никто не зарегистрирован в системе.
        	- **Сравнение служб и драйверов**. Информация о службах и драйверах хранится в одном и том же разделе реестра. Различить их можно по параметрам Start и Type
        	- **Реестр Windows**. Реестр — это база данных, в которой Windows хранит параметры конфигурации пользователя и компьютера. Всякий раз, когда вы вносите изменения в конфигурацию Windows, это изменение фиксируется в реестре. Реестр Windows организован иерархически
	- Обзор версий Windows
    	- Версии шиндовс ![22.2](22.2.png)
	- Методы инсталляции ОС Windows
    	- **Ручная установка с использованием установочного носителя:** Применяется, когда нет подходящего образа для конкретной аппаратной платформы или при небольшом количестве установок.
    	- **Автономная (необслуживаемая) установка:** Используется файл ответов, предоставляющий ответы на вопросы, задаваемые во время ручной установки. Позволяет автоматизировать установку с заданными параметрами.
    	- **Установка, сопровождаемая производителем:** Некоторые производители поставляют носители автономной установки, упрощающие процесс для конечного пользователя.
    	- **Создание копий или образов систем:** Полезно при развертывании нескольких идентичных компьютеров или серверов. Создание образов системы с помощью инструментов Microsoft, таких как WDS, Sysprep, или сторонних разработчиков.
    	- **Служба развертывания Windows (WDS):** Позволяет развертывать установочные образы и специально настроенные образы на серверах и настольных компьютерах.
    	- **Диспетчер настроек системного центра (SCCM):** Средство развертывания и управления образами систем с возможностью централизованного управления.
    	- **Инструментальный набор развертывания Microsoft (MDT):** Обеспечивает средства для создания образов, управления драйверами и приложениями, а также автоматизации процесса развертывания
23. ОС Windows: организация рабочей среды пользователя, работа с учетными записями пользователей и групп, работа с профилями пользователей. 
24. Системный реестр ОС Windows, его назначение и использование. 
	- Реестр Windows организован иерархически. На верхнем уровне имеется пять кустов реестра, которые представляют собой отдельный набор связанных параметров, структурированных как серия ключей, подразделов и значений
    	- HKEY_CLASSES_ROOT: Ассоциации файлов и приложений для открытия файлов.
    	- HKEY_CURRENT_USER (HKCU): Информация о конфигурации текущего пользователя.
    	- HKEY_LOCAL_MACHINE (HKLM): Важные параметры конфигурации компьютера.
    	- HKEY_USERS: Информация о конфигурации всех пользователей, включая текущего.
    	- HKEY_CURRENT_CONFIG: Информация о текущем профиле оборудования.
  	- Для поддержания структуры базы данных аналогичные настройки хранятся в папках и подпапках, известных как ключи и подразделы. Это упрощает ссылку на определенное значение реестра. Вы можете указать путь, объявив соответствующий куст, ключ, подразделы и значение
  	- Типы значений
    	- REG_BINARY. Необработанные двоичные данные. Эти значения обычно отображаются в шестнадцатеричном формате. Информация об оборудовании часто хранится в значениях REG_BINARY.
    	- REG_DWORD. 4-байтовые числа (32-битное целое число). Многие значения, связанные с драйверами устройств и службами, хранятся в значениях REG_DWORD. Например, значения START и TYPE для драйверов устройств всегда определяются в значениях типа REG_DWORD.
    	- REG_SZ. Текстовая строка фиксированной длины.
    	- REG_EXPAND_SZ. Текстовая строка переменной длины.
    	- REG_MULTI_SZ. Несколько строковых значений.
25. ОС Windows: планирование и назначение разрешений NTFS.
26. Средства автоматической настройки в ОС Windows.
	- Командное консольное окно и PowerShell.
    	- В Windows есть две оболочки командной строки: командная оболочка cmd и PowerShell. 
    	- Каждая оболочка — это программная программа, которая обеспечивает прямую связь между оператором и операционной системой или приложением, предоставляя среду для автоматизации ИТ-операций
    	- PowerShell был разработан для расширения возможностей командной оболочки для выполнения команд PowerShell, называемых командлетами. Командлеты похожи на команды Windows, но предоставляют более расширяемый язык сценариев
    	- PowerShell может всё, что может cmd, но не наоборот
	- BAT-файлы.
    	- BAT-файл (Batch-файл)текстовый файл, содержащий команды системы, которые могут выполняться последовательно. Расширение .cmd или .bat
    	- Для вызова другого скрипта используется команда call
    	- Для создания переменной используется команда set 
    	- 
	- WMI.
    	- Инструментарий управления Windows (WMI) — это инфраструктура для управления данными и операциями в операционных системах Windows
    	- В основе структуры данных в WBEM лежит Common Information Model (CIM),  реализующая ООП-подход к представлению компонентов системы.
    	- wbemtest.exe — графическая утилита для взаимодействия со структурой WMI на локальном или удаленном компьютере.
    	- wmic.exe — консольная утилита для взаимодействия со структурой WMI на локальном или удаленном компьютере
	- ETW.
    	- служба, которая позволяет получать события от одного или нескольких поставщиков событий в режиме реального времени или из файла *.etl за некоторый временной период. Архитектура ETW включает в себя 4 элемента (рис. 4.2.1):
        	- поставщики событий (providers)
        	- потребители событий (consumers)
        	- контроллеры ETW (controllers)
        	- сессии ETW (event tracing sessions)
      	- ![24.1](24.1.png)
	- Групповые политики.
    	- важный элемент любой среды Microsoft Active Directory (AD). Её основная цель — дать ИТ-администраторам возможность централизованно управлять пользователями и компьютерами в домене. Групповая политика состоит из набора политик, называемых объектами групповой политики (GPO).
	- Административные шаблоны.
    	- в формате XML, написанные на различных языках, которые задают параметры групповых политик, основанные на значениях реестра. Эти параметры отображаются и редактируются в локальном редакторе групповых политик на компьютере
  	- В doc-файле там ещё пункты были, но я не совсем понял, как они относятся к автоматической настройке шиндовс, так что убрал их
27. Основные понятия системы UNIX. Пользователи системы, атрибуты пользователя. Файловая структура ОС. 
28. ОС UNIX: особенности процессов, сигналы, обработка сигналов. 
	- Особенности процессов
    	- Основными активными сущностями в системе Linux являются процессы. Каждый процесс выполняет одну программу и изначально получает один поток управления. Иначе говоря, у процесса есть один счетчик команд, который отслеживает следующую исполняемую команду. Linux позволяет процессу создавать дополнительные потоки (после того, как он начинает выполнение).
    	- Системный вызов fork создает точную копию исходного процесса, называемого родительским процессом (parent process). У родительского и у дочернего процессов есть собственные (приватные) образы памяти. Если родительский процесс впоследствии изменяет какие-либо свои переменные, то эти изменения остаются невидимыми для дочернего процесса (и наоборот).
    	- fork возвращает дочернему процессу число 0, а родительскому — отличный от нуля PID дочернего процесса. getpid
    	- Типы процессов
        	- Системные процессы - часть ядра, всегда в оперативной памяти. Не имеют соответствующих исполняемых файлов, запускаются особым образом при инициализации ядра. Примеры: shed, vhand, bdfflush, kmadaemon, и init. 
        	- Демоны (daemons) фоновые процессы, работающие в фоновом режиме и обслуживающие различные системные задачи или услуги. Они часто запускаются при загрузке системы и работают независимо от активности конкретного пользователя. Типичным демоном является cron. Он просыпается раз в минуту, проверяя, не нужно ли ему что-то сделать. Есть работа-выполняет, нету-спит до след проверки. Позволяет планировать в системе Linux активность на минуты, часы, дни и месяцы вперед.
        	- Прикладные процессы - все остальные, выполняющиеся в системе, часто порождаемые пользовательским сеансом. Пример: команды, запущенные пользователем. Время их выполнения ограничено сеансом работы
	- Сигналы
    	- это способ информирования процесса со стороны ядра о происшествии некоторого события. Один процесс может посылать сигнал другому через системный вызов kill. 
	- Обработка сигналов
    	- осуществляется через установку обработчиков сигналов. Когда процесс получает сигнал, ядро отправляет управление к обработчику, который был предварительно установлен для этого сигнала. Процесс может выбрать различные действия при получении сигнала:
        	- Игнорирование (SIG_IGN): Процесс может проигнорировать сигнал, если установлен обработчик SIG_IGN (ignore). 
        	- По умолчанию (SIG_DFL): Если не установлен пользовательский обработчик, применяется действие по умолчанию (default). Например завершение процесса.
        	- Пользовательский обработчик (функция): Процесс может установить свою собственную функцию-обработчик. Когда сигнал поступает, управление передается этой функции.
29. Основные принципы функционирования Linux. Основные компоненты Linux. Дистрибутивы Linux. Файловая система Linux. 
30. ОС Linux: управление процессами, выполнение задач в фоновом режиме, изменение приоритетов выполняющихся программ. 
31. Понятие безопасности ОС. Основные угрозы безопасности ОС. Методы и защитные механизмы операционных систем. 
32. Механизмы безопасности в операционных системах семейства Windows.
33. Механизмы безопасности в операционных системах семейства Linux.