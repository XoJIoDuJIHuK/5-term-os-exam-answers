1. Операционные системы: определение, назначение, функции.
	- Операционная система — это комплект программ, которые служат интерфейсом между модулями вычислительных систем и прикладными программными приложениями, а также управляют компьютерным оборудованием и процессами вычислений, эффективным распределением вычислительных мощностей среди процессов вычислений
	- ОС управляет всеми устройствами компьютерной системы (процессорами, оперативной памятью, дисками, клавиатурой, монитором, принтерами, сетевыми устройствами и др.) и обеспечивает пользователя удобным интерфейсом для работы с аппаратурой.
	- Две основные функции (назначение) ОС:
		- предоставлять пользователю некую расширенную виртуальную машину, с которой легче работать (легче программировать), чем непосредственно с аппаратурой реального компьютера или реальной сети;
		- управлять ресурсами вычислительной системы.
	- Поэтому в специальной литературе ОС представляется всегда двояко: как расширенная виртуальная машина и как система управления ресурсами
	- Функции ОС автономного компьютера обычно группируются в соответствии с типами локальных ресурсов, которыми управляет ОС. Такие группы называют подсистемами. Наиболее важные из них:
		- подсистема управления процессами,
		- подсистема управления памятью,
		- подсистема управления файлами,
		- подсистема управления внешними устройствами,
		- подсистема пользовательского интерфейса,
		- подсистема защиты данных и администрирования
	- Функции ОС:
		- прием от пользователя (оператора) заданий или команд, сформулированных на соответствующих языках, и их обработка;
		- загрузка в ОП программ и их исполнение;инициация программы (передача ей управления);
		- прием и исполнение программных запросов на запуск, приостановку, остановку других программ; организация взаимодействия между задачами;
		- идентификация всех программ и данных;
		- обеспечение работы системы управления файлами и/или систем управления БД;
		- обеспечение режима мультипрограммирования (многозадачности);
		- планирование и диспетчеризация задач;
		- обеспечение функций по организации и управлению операциями ввода/вывода;
		- удовлетворение жестким ограничениям на время ответа в режиме реального времени (для соответствующих ОС);
		- управление памятью, организация виртуальной памяти;
		- организация механизмов обмена сообщениями и данными между выполняющимися программами;
		- защита одной программы от влияния другой; обеспечение сохранности данных;
		- аутентификация, авторизация и другие средства обеспечения безопасности;
		- предоставление услуг на случай частичного сбоя системы;
		- обеспечение работы систем программирования;
		- параллельное исполнение нескольких задач.

2. Операционные системы: классификация, основные этапы развития, особенности современного этапа развития
	- Классификация
		- В зависимости от способа организации вычислений:
			- Системы пакетной обработки – основной задачей является организация наибольшего количества вычислительных процессов за единицу времени.
			Определенные процессы объединяются в пакет, который затем обрабатывает ОС.
			- Системы разделения времени – создание возможности единовременного взаимодействия с устройством сразу несколькими людьми. В порядке очереди каждый пользователь получает определенный промежуток процессорного времени.
			- Системы реального времени – организация работы каждой задачи за определенный промежуток времени, присущий каждой конкретной задаче.
		- В зависимости от типа ядра:
			- OС с монолитным ядром;
			- OС с микроядром;
			- OС с гибридным ядром.
		- В зависимости от количества единовременно решаемых задач:
			- однозадачные;
			- многозадачные;
		- В зависимости от количества пользователей:
			- однопользовательские;
			- многопользовательские.
		- В зависимости от количества поддерживаемых процессоров:
			- однопроцессорные
			- многопроцессорные
		- В зависимости от возможности работы в компьютерной сети:
			- локальные – автономные ОС, которые не позволяют работать с компьютерными сетями;
			- сетевые – ОС с поддержкой компьютерных сетей.
		- В зависимости от роли в сетевом взаимодействии:
			- серверные – ОС, открывающие доступ к ресурсам сети и осуществляющие управление сетевой инфраструктурой;
			- клиентские – ОС, которые имеют возможность получения доступа к ресурсам сети.
		- В зависимости от типа лицензии:
			- открытые – ОС с открытым исходным кодом, который можно изучать и редактировать;
			- проприетарные – ОС, связанные с определенным правообладателем и, как правило, имеющие закрытый исходный код.
	- Основные этапы развития
		- Первое (45-55гг)
			- программы в машинных кодах
			- загрузка программы в память вручную или с перфокарт
			- система выполняет одну операцию одновременно (последовательная обработка данных)
			- в самом конце появляется первое системное ПО
		- Второе (55-65гг)
			- использование небольших недорогих компьютеров для записи заданий на магнитную ленту вместо того, чтобы готовить задания непосредственно на больших машинах. Программа, считывающая задания с ленты и запускающая их на выполнение, является прообразом ОС
			- научные и технические вычисления
			- появление настоящих ОС (Fortran Monitor System, IBSYS)
			- разделение труда на операторов, разработчиков и специалистов по эксплуатации
		- Третье (65-80гг)
			- многозадачность (асинхронность)
			- подкачка данных ( способность считывать задание с перфокарт на диск по мере того, как их приносили в машинный зал. При окончании выполнения каждого текущего задания операционная система могла загружать новое задание с диска в освободившийся раздел памяти и запускать это задание)
			- режим разделения времени (вариант многозадачности, при котором у каждого пользователя есть свой диалоговый терминал)
		- Четвёртое (80-05гг)
			- персональные компьютеры
			- MS-DOS
			- сначала текстовый, затем графический интерфейс
			- распределённые операционные системы со свойством масштабируемости
		- Пятое (05-н.в.)
			- многоядерность
			- ОС для смартфонов
			- Android
			- виртуализация (предоставление вычислительных ресурсов, абстрагированное от аппаратной реализации (память, устройства ввода-вывода, ОС и т.д.), например, облачные технологии)
	- Особенности современного развития
		- На современном этапе развития операционных систем на передний план вышли средства обеспечения безопасности. Это связано с возросшей ценностью информации, обрабатываемой компьютерами, а также с повышенным уровнем угроз, существующих при передаче данных по сетям, особенно по публичным, таким как Интернет. Многие операционные системы обладают сегодня развитыми средствами защиты информации, основанными на шифрации данных, аутентификации и авторизации. Современным операционным системам присуща многоплатформенность, т.е. способность работать на совершенно различных типах компьютеров. В последние годы получила дальнейшее развитие долговременная тенденция повышения удобства работы человека с компьютером. Эффективность работы человека становится основным фактором, определяющим эффективность вычислительной системы в целом. Усилия человека не должны тратиться на настройку параметров вычислительного процесса, как это происходило в ОС предыдущих поколений. Постоянно повышается удобство интерактивной работы с компьютером путем включения в операционную систему развитых графических интерфейсов, использующих наряду с графикой звук и видеоизображение

3. Компоненты архитектуры вычислительных систем, их назначение и взаимодействие.
	- Классическая архитектура (фон Нейман)
		- Компоненты
			- АЛУ (арифметические и логические операции)
			- Управляющее устройство, выполняющее процесс выполнения программ
			- Внешнее запоминающее устройство для хранения программ и данных
			- ОЗУ
			- Устройство ввода-вывода информации
	- Шинная архитектура
		- Компоненты
			- **Контроллер** можно рассматривать как специализированный процессор, управляющий работой "вверенного ему" внешнего устройства по специальным встроенным программам обмена. Такой процессор имеет собственную систему команд. Например, контроллер на гибких магнитных дисках (дисковода) умеет позиционировать головку на нужную дорожку диска, читать или записывать сектор, форматировать дорожку и т.п. Результаты выполнения каждой операции заносятся во внутренние регистры памяти контроллера, которые могут быть в дальнейшем прочитаны центральным процессором накопителя
			- Для связи между отдельными функциональными узлами ЭВМ используется **общая шина**. Шина — это несколько проводников, соединяющих несколько устройств. Шины можно разделить на категории в соответствии с выполняемыми функциями. Они могут быть внутренними по отношению к процессору и служить для передачи данных в АЛУ и из АЛУ, а могут быть внешними по отношению к процессору и связывать процессор с памятью или устройствами ввода-вывода
				- Шина данных. По этой шине данные передаются между различными устройствами. Разрядность шины данных определяется разрядностью процессора, т. е. количеством двоичных разрядов, которые процессор обрабатывает за один такт. Со времени создания первого персонального компьютера (1975 г.), разрядность шины данных увеличилась с 8 до 64 бит.
				- Шина адреса. Каждая ячейка оперативной памяти имеет свой адрес. Адрес передается по адресной шине. Разрядность шины адреса определяет адресное пространство процессора, т. е. количество ячеек оперативной памяти, которые могут иметь уникальные адреса. Количество адресуемых ячеек памяти равно 2^n^, где n – разрядность шины адреса. В первых персональных компьютерах разрядность шины адреса составляла 16 бит, в современных персональных компьютерах разрядность шины адреса составляет 64 бита.
				- Шина управления. По шине управления передаются сигналы, определяющие характер обмена информацией по магистрали. Сигналы управления определяют, какую операцию - считывание или запись информации из памяти — нужно производить, синхронизируют обмен информацией между устройствами и т. д.
  			- **Процессор** - "мозг" компьютера. Выбирает команды из ОЗУ и выполняет их. Цикл выплнения: выборка первой команды, декодирование, выполнение до тех пор, пока программа не кончится.
	  			Специальные регистры:
				- счётчик команд (адрес следующей команды)
				- адрес вершины стека
				- слово состояния программы (хрен знает, что это такое, но в него входит бит, указывающий, в каком режиме работает программа (пользовательский или ядра))
				От простого цикла извлечения команд по одной давно отказались, теперь используют **конвейер** - исполнение нескольких команд одновременно. Процессоры с суперскалярной архитектурой имют несколько исполнительных блоков, котооые могут исполнять команды не в порядке следования
				Два режима:
				- ядра (все команды)
				- пользовательский (ограниченное множество команд и возможностей)
				Архитектуры процессоров:
				- CISC (Complex Instruction Set Computer): использование сложных инструкций процессора, выполняющих много действий, написанных на микрокоде (простых командах) и хранящихся в readonly памяти. Микрокод очень сложно отлаживать, нельзя нормально ковейеризировать, потому что инструкции разные по длине выполнения, а пока не декодируешь - не поймёшь, что за инструкция, жрёт больше энергии. Но зато писать ассемблерный код для CISC-процессора быстрее, проще и приятнее
				- RISC (Reduced...): использование нескольких простых команд вместо одной сложной (и вот мы снова тут), т.к. большинство сложных инструкций почти не используются, и можно не заниматься отладкой микрокода. Она оптимизирована для компиляторов, а не для людей. Использует конвейеризацию: разделение инструкций на этапы, каждый из которых выполняется приблизительно одинаково по времени. Пять этапов:
					- Извлечение команды из памяти и увеличение счётчика команд
					- Декодирование
					- Выполнение
					- Доступ к памяти, если это необходимо
					- Запись результатов в нужный регистр
  				- RISC-V (Five): открытая, бесплатная, включает в себя небольшой фиксированный набор команд с модульными фиксированными стандартными расширениями. Гибкая, поддерживает инновации (производитель может просто добавить свой модуль команд), снижение затрат и ускорение выхода на рынок
			- Память
				- используется иерархия уровней, потому что память физически не может быть и быстрой, и объёмной, и дешёвой
					- регистры (не уступают в быстродействии процессору)
					- кеш (обычно делится на кеш-строки по 64 байта)
					- основная память
					- магнитный диск
					- магнитная лента
	  		- Шины PCI и PCIe
				- Первая старше (очевидно) и состоит из собственно шины, к которой подключается вся периферия и мост, соединящий процессор и память (они к шине непосредственно не подключены)
				- Вторая имеет корневой комплекс вместо моста. У него есть порты, к которым подключаются коммутаторы PCIe, соединяющие несколько устройств PCIe, либо просто устройства PCIe, либо мост PCI, соединяющий корневой комплекс с шиной PCI. Соединения между устрйоствами последовательные и 1-битные вместо 8, 16, 32 и 64-битных у PCI. Какми-то образом это увеличивает пропускную способность. Все взаимодействия являются одноранговыми. Когда процессор хочет обратиться к устройству, он отправляет этому устройству пакет и обычно получает ответ. Пакет проходит через корневой комплекс на материнской плате, а затем передается устройству — как правило, через коммутатор
  			- Шина USB
  			- Видеокарты (устройство, преобразующее цифровую информацию в форму, пригодную для дальнейшего вывода на экран монитора). Может иметь свой графический процессор, снимая эту задачу с ЦП. АПИ для программирования графических приложений:
				- Direct3D
				- OpenGL
				- Vulkan

4. Задачи операционной системы по управлению и организации работы компьютера.
	- Группы функций
		- Виртуальная память. Механизм виртуальной памяти используется многими операционными системами. Она позволяет создать впечатление, будто у машины больше памяти, чем есть на самом деле.
		- Файловый ввод-вывод. Это понятие более высокого уровня, чем команды вводавывода, которые мы рассматривали в предыдущей главе.
		- Параллелизм (как организовано одновременное выполнение нескольких процессов, обмен информацией и синхронизация)
  	- Более подробно
		- Параллельное функционирование модулей ввода (работающих с блоками, имеющими фиксированный размер и свой адрес (например, жёсткие диски) или байтами (не поддерживают адресацию и поиск информации) (например, сетевые адаптеры)), вывода информации и процессора.
		- Организация кэширования данных и выполнение согласования скоростей информационного обмена.
		- Разбиение модулей и информационных данных среди процессов.
		- Организация удобной работы логического интерфейса между модулями и оставшейся частью системы.
		- Организация поддержки различных устройств с обеспечением возможности просто их добавить.
		- Режим динамической загрузки и выгрузки драйверов.
		- Обеспечение поддержки набора файловых систем.
  	- Главным принципом построения программного обеспечения ввода и вывода информации является разбиение его на отдельные уровни. При этом нижние уровни должны обеспечивать защиту особенностей своего оборудования от влияния верхних уровней, которые призваны только осуществлять удобное интерфейсное обслуживание пользователей. Ещё одним базовым вопросом в организации программ информационного ввода и вывода считается обработка ошибок. Общеизвестно, что обработку ошибок нужно осуществлять максимально близко к оборудованию. Когда контроллер находит ошибку чтения, то ему необходимо сделать попытку её коррекции. Если эта попытка окажется неудачной, то дальше коррекцией ошибки занимается драйвер модуля. Часто ошибки пропадают при повторном выполнении операции ввода или вывода информации. Но когда ликвидацию ошибки не удалось выполнить на нижнем уровне, идёт сообщение об ошибке на верхний уровень
  	- Программное обеспечение ввода и вывода информации делится на следующие уровни:
		- Уровень обработки прерываний.
		- Уровень драйверов оборудования
		- Уровень независимого от оборудования слоя операционной системы.
		- Пользовательский уровень программного обеспечения
  	- Виртуализация -  технология, которая позволяет создавать несколько сред или выделенных ресурсов из единой физической аппаратной системы. Программное обеспечение, гипервизор, напрямую подключается к этой аппаратной системе и позволяет разбить ее на отдельные, безопасные среды – виртуальные машины. По идее, гипервизор должен распределять аппаратные ресурсы между виртуальными машинами так, чтобы процессы выполнялись быстрее. Физическая машина с гипервизором называется хостом, а виртуальные машины, которые используют ресурсы данного хоста – гостями
  	- Прерывания
    	- Инструкция перехвата TRAP осуществляет переключение из пользовательского режима в режим ядра и запускает операционную систему. Когда обработка вызова будет завершена, управление возвращается пользовательской программе и выполняется команда, которая следует за системным вызовом
    	- Все прерывания и особые ситуации имеют уникальные идентификационные номера. Эти номера называются векторами прерываний и лежат в пределах от 0 до 255. Векторы от 0 до 31 отведены для особых ситуаций и немаскируемого прерывания, причем некоторые из них зарезервированы и не должны использоваться программами. Векторы от 32 до 255 свободны для любого использования пользовательскими программами и внешними устройствами
    	- Классификация
        	- в зависимости от источника
            	- аппаратные (от оборудования)
            	- программные (внутри программы)
            	- исиключения (внутри микропроцессора, например, деление на ноль)
          	- общая классификация
            	- внешние (аппаратные, вложенных нет)
            	- внутренние (внутри микропроцессора)
      	- х86 (реальный режим)
        	- прекращение выполнения текущей программы (автоматическое сохранение регистров, указывающих на следующую команду и флаги, программа сама должна сохранить регистры общего назначения)
        	- переход к выполнению обработки прерывания (определение источника прерывания и вызов обработчика)
        	- возврат управления прерванной программе (привод стека в состояние до прерывания)

5. Структура ядра и его функции. Объекты ядра. Основные операции над объектами ядра. 
	- Структура ядра и его функции
		- Ядро — низкоуровневая основа любой операционной системы, выполняемая аппаратурой в особом привилегированном режиме. Ядро загружается в память один раз и находится в памяти резидентно (постоянно), по одним и тем же адресам. Обеспечивает архитектуру связи с приложениями, организует и регулирует доступ к ресурсам компьютера.
	 	- Под архитектурой ОС обычно понимают структурную организацию ОС на основе программных модулей
	 	- Обобщённая структура ОС состоит из ядра, окружённого системными услугами, поддержкой сети, работой с устройствами, системой разработки программ, работой с пользователями, приложениями.
	 	- Ядро является модулями, выполняющими основные функции ОС:
		 	- управление памятью
		 	- управление процессами
		 	- управление устройствами ввода-вывода
	 	- Функции, входящие в состав ядра
		 	- внутрисистемные (недоступные для приложений)
		 	- апи (обслуживают системные вызовы, предоставляют доступ к системным ресурсам в удобной форме)
	   	- Функции модулей ядра — наиболее часто используемые функции ОС, скорость их выполнения определяет производительность всей системы в целом
	   	- Остальные модули выполняют полезные, но менее значимые функции:
		 	- утилиты — программы, которые решают отдельные задачи управления и сопровождения компьютерной системы (сжатие, дефрагментация …);
		 	- библиотеки процедур и функций различного назначения (библиотека математических функций, библиотека функций ввода-вывода и т.д.);
		 	- программы предоставления пользователю дополнительных услуг — специальный вариант пользовательского интерфейса, калькулятор, некоторые игры (какие, например, поставляются в составе ОС);
		 	- системные обрабатывающие программы — текстовые и графические редакторы, компиляторы, компоновщики, отладчики
	   	- Задачи, выполняемые ядром
		 	- обработка прерываний
		 	- формирование и ликвидация процессов
		 	- переключение состояний и диспетчеризация процессов
		 	- синхронизация и обмен данными между процессами
		 	- ввод и вывод
		 	- распределение ресурсов
		 	- поддержка файловых систем
	   	- Подсистемы
		 	- управления процессами (выполняет также распределениесистемных ресурсов между процессами)
		 	- управления памятью (оперативной; распределяет память процессам, выгружает их в файл подкачки)
		 	- файловая (обеспечивает унифицированный доступ к данным (например, чтобы использование одних и тех же функций выдавало одинаковый результат для файлов, принтеров и терминалов))
		 	- ввода-вывода (выполняет запросы файловой подсистемы и подсистемы управления процессами на доступ к периферии. Взаимодействует с программами ядра)
	   	- Виды ядер
		 	- монолит (по сути, это просто большой набор сервисных функций. Формируется из обширного комплекта абстракций  борудования. Все элементы монолитного ядра работают в едином адресном формате. При такой организации операционной системы все составляющие части её ядра выступают как элементы основной программы, применяют одни и те же системы организации данных и работают друг с другом, используя непосредственный вызов процедуры)
		 	- модульная (современная, не требует реструктуризации для разного аппаратного обечпечения, может подгружать разные модули как на лету, так и при переконфигурировании и перезагрузке системы. Но так как все модули работают в режиме ядра, то сбой в одном из них потянет за собой всё ядро, и надо будет перезагружать ОС)
		 	- микро (решает небольшой набор задач и имеет небольшой набор абстракций. Главный признак - распределение практически всех драйверов и элементов в процессах сервиса)
		 	- экзо (предоставляет только возможность взаимного обмена между процессами и надёжного распределения и высвобождения ресурсов. Распределяет ресурсы между виртуальными машинами и следит, чтобы ни одна из них не лезла в чужие ресурсы)
		 	- нано (решает лишь проблему аппаратных прерываний, генерируемых разными блоками компьютера. Передаёт результаты вышестоящей по рангу программе при помощи прерываний)
		 	- гибридная (ускоренная модификация микроядра)
		 	- комбинированная (коктейль из всего вышеперечисленного)
  	- Объекты ядра
		- Используются системой и приложениями для управления множеством разных ресурсов (процессов, потоков). Приложения не могут обращаться к ним напрямую. На самом деле это просто блоки памяти, выделенные ядром и доступные только ему. Блок представляет собой структуру данных, в элементах которой содержится информация об объекте. Некоторые элементы (дескриптор защиты, счетчик числа пользователей и др.) присутствуют во всех объектах, но большая их часть специфична для объектов конкретного типа.
		- **Объект** — это коллекция данных, являющихся частью режима ядра операционной системы, которыми управляет Диспетчер объектов Windows
		- Категории
			- устройств
			- файлов
			- символические ссылки
			- разделы реестра
			- потоки и процессы
			- диспетчера ядра (события, мьютексы...)
			- обратного вызова
			- объекты section
	  	- Взаимодествие программ с объектами подчиняется строгим правилам. Когда мы создаем объект ядра в операционной системе Windows, функция возвращает описатель, идентифицирующий созданный объект (HANDLE). Все операции с текущим объектом ядра возможны только при передаче этого описателя управляющей функции. При этом использовать один описатель в разных процессах (за одним исключением) низя.
	  	- Объекты принадлежат ядру, а не процессу. Завершив создавший его процесс, объект не разрушится, пока есть другие процессы, использующие его. При этом используется счётчик, присваиваемый объекту ядром (+1 или -1, всё такое)
  	- Основные операции над объектами ядра
		- Система позволяет динамически создавать новые типы объектов. В этом случае предполагается регистрация его методов у диспетчера объектов
		- Для работы с объектами есть функции фреймворка ОС (CreateFile, OpenMutex...). Это библиотечные процедуры, за которыми стоят сервисы Windows и методы объектов
		- Функция CreateFile, несмотря на первое впечатление от ее имени, используется и при работе с уже существующими файлами, так как слово File здесь обозначает не файл на диске, а объект ядра типа File
		- Некоторые объекты ядра имеют разрешение Synchronize. Это означает, что их можно использовать как для синхронизации потоков

6. Утилиты. Системные обрабатывающие программы. Библиотеки процедур. Программы дополнительных услуг. 
	- Утилиты
		- Системное программное обеспечение, которое помогает поддерживать правильное и бесперебойное функционирование компьютерной системы. Они помогают операционной системе управлять, организовывать, поддерживать и оптимизировать функционирование компьютерной системы
		- Типы
			- Антивирусы
			- Системы управления файлами
			- Инструменты сжатия
			- Инструменты управления дисками (например, разбиение на разделы)
			- Инструменты очистки диска
			- Дефрагментация диска
			- Резервного копирования
	- Системные обрабатывающие команды
		- Обрабатывающие системные программы отличаются от управляющих программ как по своим функциям, так и по способу их инициирования (запуска) (каво?)
		- Функции и тип устройства в зависимости от преобладающей функции:
			- Перенос информации (между устройствами или в пределах одного устройства) (утилита)
			- Преобразование информации (после считывания преобразует и лишь затем записывает её дальше) (лингвистический процессор, основная функция которого - перевод описания алгоритма с одного языка на другой (с человеческого на машинный))
				- транслятор (выдаёт целиком)
					- компилятор (программа на высоком уровне)
					- ассемблер (программа на языке ассемблера (какой ужас, что это вообще?))
				- интерпретатор (выдаёт постепенно), например, PowerShell
	- Библиотеки процедур
		- Библиотеки процедур и функций различного назначения включены в категорию вспомогательных модулей операционной системы. К ним можно отнести библиотеки математических функций, библиотеки функций ввода-вывода и т.д.
		- Библиотеки — это набор функций, которые могут использоваться в различных программах.
			- Статические
			- Динамические
		- Расположение системных библиотек
			- шиндовс: System32, System64
			- linux: /lib, /usr/lib
	- Программы дополнительных услуг
		- В эту категорию входит большое количество разнообразных программ: специальный вариант пользовательского интерфейса, калькулятор, некоторые игры (какие, например, поставляются в составе ОС)

7. Понятие процесса. Системные и пользовательские процессы. Операции над процессами. 
	- Процесс
 		- Процесс (process) - это некоторая часть (единица) работы, создаваемая операционной системой. Чтобы некоторую часть работы можно было назвать процессом, она должна иметь адресное пространство, назначаемое операционной системой, и идентификатор, или идентификационный номер (id процесса). 
		- Процесс должен обладать определенным статусом и иметь свой элемент в таблице процессов. В соответствии со стандартом POSIX он должен содержать один или несколько потоков управления, выполняющихся в рамках его. Процесс состоит из множества выполняющихся инструкций, размещенных в адресном пространстве этого процесса. Адресное пространство процесса распределяется между инструкциями, данными, принадлежащими процессу, и стеками, обеспечивающими вызовы функций и хранение локальных переменных.
		- Для реализации модели процессов операционная система ведет таблицу (состоящую из массива структур), называемую таблицей процессов, в которой каждая запись соответствует какому-нибудь процессу. Эти записи содержат важную информацию о состоянии процесса, включая счетчик команд, указатель стека, распределение памяти, состояние открытых им файлов, его учетную и планировочную информацию и все остальное, касающееся процесса, что должно быть сохранено, когда процесс переключается из состояния выполнения в состояние готовности или блокировки, чтобы позже он мог возобновить выполнение, как будто никогда не останавливался.
		- Информация о процессах хранится в одной структуре данных, которая называется блоком управления процессом PCB (Process Control Block). Блок управления процессом является моделью процесса для операционной системы. Любая операция, производимая операционной системой над процессом, вызывает изменения в PCB. Содержимое PCB между операциями остается постоянным.
		- Процесс: абстракция, описывающая выполняющуюся программу.
		- Процесс — это просто экземпляр выполняемой программы, включая текущие значения счетчика команд, регистров и переменных. 
		- Разумеется, на самом деле настоящий центральный процессор постоянно переключается между процессами, но чтобы понять систему, куда проще думать о наборе процессов, запущенных в (псевдо) параллельном режиме, чем пытаться отслеживать, как центральный процессор переключается между программами. Это постоянное переключение между процессами называется мультипрограммированием, или многозадачным режимом работы.
		- Процесс — это своего рода действия. У него есть программа, входные и выходные данные и состояние. Один процессор может совместно использоваться несколькими процессами в соответствии с неким алгоритмом планирования, который используется для определения того, когда остановить один процесс и обслужить другой. 
		- Совокупность регистрового, системного и пользовательского контекстов процесса называется контекстом процесса. 
			- Регистровым контекстом процесса называется содержимое всех регистров общего назначения процессора (включая значение программного счетчика). 
			- Содержимое остальных регистров процессора называется системным контекстом процесса. 
			- [Информации, получаемой с регистровых и системных контекстов, достаточно для управления работой процесса в операционной системе.]
			- Пользовательским контекстом называются данные, находящиеся в адресном пространстве процесса.
	- Различают пользовательские процессы и системные. 
		- Процессы, которые выполняют системный код, называются системными и применяются к системе в целом. Они занимаются выполнением таких служебных задач, как распределение памяти, обмен страницами между внутренним и вспомогательным запоминающими устройствами, контроль устройств и т.п. Они также выполняют некоторые задачи «по поручению» пользовательских процессов, например, делают запросы на ввод-вывод данных, выделяют память и т.д.
		- Пользовательские процессы выполняют собственный код и иногда обращаются к системным функциям. Выполняя собственный код, пользовательский процесс пребывает в пользовательском режиме (user mode). В пользовательском режиме процесс не может выполнять определенные привилегированные машинные команды. 
			- При вызове системных функций (например read, write или open) пользовательский процесс выполняет инструкции операционной системы. При этом пользовательский процесс «удерживает» процессор до тех пор, пока не будет выполнен системный вызов. Для выполнения системного вызова процессор обращается к ядру операционной системы. В это время о пользовательском процессе говорят, что он пребывает в привилегированном режиме, или режиме ядра (kernel mode), и не может быть выгружен никаким другим пользовательским процессом.
	- Операции над процессами
		- Запуск процесса (из числа процессов, находящихся в состоянии готовность, операционная система выбирает один процесс для последующего исполнения). 
		- Приостановка процесса (работа процесса, находящегося в состоянии исполнение, приостанавливается в результате какого-либо прерывания). 
		- Блокирование процесса (процесс блокируется, когда он не может продолжать работу, не дождавшись возникновения какого-либо события в вычислительной системе). 
		- Разблокирование процесса (после возникновения в системе какого-либо события операционной системе нужно точно определить, какое именно событие произошло). 
		- Переключение контекста.
  	- Подробнее про создание, завершение, состояния
 		- Создание процесса
   			- При запуске операционной системы создаются, как правило, несколько процессов.
			- Некоторые из них представляют собой высокоприоритетные процессы, то есть процессы, взаимодействующие с пользователями и выполняющие для них определенную работу. Остальные являются фоновыми процессами, не связанными с конкретными пользователями, но выполняющими ряд специфических функций.
			- Фоновые процессы, предназначенные для обработки какой-либо активной деятельности, (связанной, например, с электронной почтой, веб-страницами, новостями, выводом информации на печать и т. д.,) называются демонами.
			- В Windows одним вызовом функции Win32 CreateProcess создается процесс, и в него загружается нужная программа.
			- В UNIX существует только один системный вызов для создания нового процесса — fork. Этот вызов создает точную копию вызывающего процесса. После выполнения системного вызова fork два процесса, родительский и дочерний, имеют единый образ памяти, единые строки описания конфигурации и одни и те же открытые файлы. Обычно после этого дочерний процесс изменяет образ памяти и запускает новую программу, выполняя системный вызов execve или ему подобный.
			- В обеих системах, UNIX и Windows, после создания процесса родительский и дочерний процессы обладают своими собственными, отдельными адресными пространствами. 
		- Завершение процесса
 			- Рано или поздно новые процессы будут завершены, обычно в силу следующих обстоятельств:
				- обычного выхода (добровольно);
				- выхода при возникновении ошибки (добровольно);
				- возникновения фатальной ошибки (принудительно);
				- уничтожения другим процессом (принудительно).
			- Системный вызов по окончанию работы процесса: в UNIX - exit, а в Windows — ExitProcess.
   		- Состояния процесса
	 			- выполняемый (в данный момент использующий центральный процессор);
			- готовый (работоспособный, но временно приостановленный, чтобы дать возможность выполнения другому процессу);
			- заблокированный (неспособный выполняться, пока не возникнет какое-нибудь внешнее событие).

8. Организация межпроцессного взаимодействия в ОС. Сигналы. Каналы. Классические проблемы межпроцессного взаимодействия.
	- Организация межпроцессного взаимодействия в ОС
	  	- Взаимоисключение - проблема, когда каждый процесс, обращающийся к разделяемым данным, исключает для всех других процессов возможность одновременного с ним обращения к этим данным
	  	- Уровни IPC
		  	- локальный (очевидно, только на локальном компьютере): каналы, разделяемая память, очереди сообщений
		  	- удалённый (очевидно, через сеть)
		  	- высокоуровневый (обычно подразумеваются пакеты ПО, реализующего промежуточный слой между системной платформой и приложением)
	  	- Методы
		  	- Сигнал
		  	- Файл
		  	- Сокет
		  	- Канал
		  	- Именованный канал
		  	- Семафор
		  	- Разделяемая память
		  	- Обмен сообщениями (без разделения)
		  	- File mapping
		  	- Очередь сообщений
		  	- Почтовый ящик
  	- Сигналы
		- Сигнал в операционных системах семейства Unix — асинхронное уведомление процесса о каком-либо событии, один из основных способов взаимодействия между процессами. Когда сигнал послан процессу, операционная система прерывает выполнение процесса, при этом, если процесс установил собственный обработчик сигнала, операционная система запускает этот обработчик, передав ему информацию о сигнале, если процесс не установил обработчик, то выполняется обработчик по умолчанию
		- Классы
			- системные
			- от устройств
			- пользовательские
	  	- Части механизма передачи сигналов
			- установление и обозначение сигналов в виде целочисленных значений
			- маркер в строке таблицы процессов для прибывших сигналов
			- таблица с адресами функций, определяющих реакцию на прибывшие сигналы
	  	- Как только сигнал приходит, он отмечается записью в таблице процессов. Если этот сигнал предназначен для процесса, то по таблице указателей функций в структуре описания процесса выясняется, как нужно реагировать на этот сигнал. При этом номер сигнала служит индексом таблицы
	  	- Варианты реакции на сигнал
			- вызов собственной функции-обработчика
			- игнор
			- использование прдустановленного обработчика
	  	- Можно пожалуйста я не буду копипастить все 24 сигнала из таблички? Есть сигнал SIGKILL, он завершает программу
  	- Каналы
		- Канал (pipe) представляет собой средство связи стандартного вывода одного процесса со стандартным вводом другого. Каналы старейший из инструментов IPC, существующий приблизительно со времени появления самых ранних версий оперативной системы UNIX. Для реализации IPC возможно использование полудуплексных и/или именованных каналов (FIFO)
		- Для создания канала используется системный вызов pipe(). Его формат следующий:
			```
			#include <inistd.h>
			int pipe (int fd[2]);
			```
		- Аргументом функции является указатель на массив двух целых чисел, в котором функция возвращает два файловых дескриптора. Первый из них предназначен для чтения данных из канала, второй - для записи в него. Читать и писать в канал можно при помощи ```read()``` и ```write()```
  	- Классические проблемы
		- Синхронный доступ. Если все процессы считывают данные из файла, то в большинстве случае проблем не возникает. Однако, при попытке одним из процессов изменить этот файл, могут возникнуть так называемые конкурентные ситуации (race conditions).
		- Дисциплина доступа. Если нужно, чтобы как можно большее количество пользователей могли записывать данные, организуется так называемая очередь (по правилу «один пишет, несколько читают»). Практически организуется две очереди: одна — для чтения, другая — для записи. Такую дисциплину доступа можно организовать с помощью барьеров (блокировок). При этом создается общий барьер для считывателей, так как несколько процессов могут одновременно считывать данные, а также отдельный барьер для процесса-писателя. Такая организация предотвращает взаимные помехи в работе.
		- Голодание процессов. Организация дисциплины доступа может привести к ситуации, когда процесс будет длительно ждать своей очереди для записи данных. Поэтому иногда нужно организовывать очереди с приоритетами
		- Управление потоком. Если нельзя точно определить, какой из процессов запрашивает или возвращает свои данные в нужный компьютер первым, используется так называемое взаимодействие по модели "клиент-сервер". При этом используются один или несколько клиентов и один сервер. Клиент посылает запрос серверу, а сервер отвечает на него. После этого клиент должен дождаться ответа сервера, чтобы продолжать дальнейшее взаимодействие
		- Тупик (deadlock). Не маленькие, и так это знаете
		- Там ещё две задачи: про философов и читателей с писателями, но я их сюда копировать не буду

9.  Концепция потока. Параллельное исполнение потоков. Главный поток процесса. 
	- Поток
 		- Поток выполнения (thread) - наименьшая единица обработки, исполнение которой может быть назначено ядром операционной системы. Несколько потоков выполнения могут существовать в рамках одного и того же процесса и совместно использовать ресурсы, такие как память, тогда как процессы не разделяют этих ресурсов. В частности, потоки выполнения разделяют инструкции процесса (его код) и его контекст (значения переменных, которые они имеют в любой момент времени).
		- Преимущества потоков
			- Код программы может выполняться, даже если некоторые действия заблокированы. 
			- Легкость и быстрота их создания (по сравнению с процессами). 
			- Потоки довольно просто обмениваются данными по сравнению с процессами. 
			- Улучшает общую производительность системы при ожиданиях завершения операций ввода-вывода. 
			- На многопроцессорных системах могут повысить быстродействие за счет параллельных вычислений.
		- Недостатки потоков
			- При программировании приложения с множественными потоками необходимо постоянно думать о потокобезопасности (thread safety). 
			- Один неправильно работающий поток может повредить остальные, так как потоки делят общее адресное пространство. 
			- Потоки конкурируют друг с другом в адресном пространстве. Стек и thread-local storage, занимая часть виртуального адресного пространства процесса, тем самым делают его недоступным для других потоков. 
		- POSIX Threads - стандарт POSIX-реализации потоков. Стандарт POSIX.1c, Threads extensions, определяет API для управления потоками, их синхронизации и планирования. Библиотеки, реализующие этот стандарт (и функции этого стандарта), обычно называются pthreads.
		- В среде Microsoft Windows концепция иная, там процесс - это контейнер для потоков. Процесс-контейнер содержит как минимум один поток. Если потоков в процессе несколько, приложение (процесс) становится многопоточным. Процесс - это исполнение программы. Операционная система использует процессы для разделения исполняемых приложений. Поток - это основная единица, которой операционная система выделяет время процессора.
  		- Классическая модель потоков
			- Процесс является способом группировки в единое целое взаимосвязанных ресурсов. У процесса есть адресное пространство, содержащее текст программы и данные, а также другие ресурсы. Эти ресурсы могут включать открытые файлы, необработанные аварийные сигналы, обработчики сигналов, учетную информацию и т. д. Управление этими ресурсами можно значительно облегчить, если собрать их воедино в виде процесса. У потока есть счетчик команд, отслеживающий, какую очередную инструкцию нужно выполнять. У него есть регистры, в которых содержатся текущие рабочие переменные. У него есть стек с протоколом выполнения, содержащим по одному фрейму для каждой вызванной, но еще не возвратившей управление процедуры. Хотя поток может быть выполнен в рамках какого-нибудь процесса, сам поток и его процесс являются разными понятиями и должны рассматриваться по отдельности. Процессы используются для группировки ресурсов в единое образование, а потоки являются сущностью, распределяемой для выполнения на центральном процессоре. Подобно традиционному процессу (то есть процессу только с одним потоком), поток должен быть в одном из следующих состояний: выполняемый, заблокированный, готовый или завершенный. Каждый поток имеет собственный стек.
		- В Linux потоки реализованы с помощью системного вызова clone(). Также существуют библиотечные функции, которые служат оберткой для системного вызова clone(). В Windows для создания потоков используется функция CreateThread.
		- В Windows процесс активен до тех пор, пока выполняются его обычные, не фоновые потоки. Это не относится к фоновым потокам. Фоновые потоки немедленно завершаются, как только завершились все активные потоки. 
	- Параллельное исполнение потоков
		- Многопоточность: процесс, порождённый в операционной системе, может состоять из нескольких потоков, выполняющихся «параллельно», то есть без предписанного порядка во времени.
		- Одновременное выполнение потоков одного процесса называется параллелизмом (parallelism). Параллельное выполнение потоков в рамках одного процесса возможно только в многоядерных системах и не является обязательным поведением. В одноядерных системах многопоточность может быть только последовательной.
		- Термин "параллельность" в контексте вытесняющей многозадачности операционной системы: операционная система выделяет потоку некоторый квант времени, а затем переключается на другой поток.
		- Все потоки, выполняясь внутри своего процесса, разделяют общую глобальную память — данные и сегменты кучи.
		- Наиболее важные виды взаимодействия параллельных потоков: 
			- совместное использование разделяемых данных (необходим взаимно-исключающий доступ к данным);
			- асинхронное взаимодействие (вводится посредник-буфер между параллельными потоками);
			- синхронное взаимодействие (оба взаимодействующих потока подходят к точке синхронизации, обмениваются данными и затем продолжают работать параллельно и независимо. Если один из потоков подошел к точке синхронизации раньше, то он дожидается партнера).
	- Главный поток
 		- По умолчанию процесс создается с одним потоком, называемым главным или основным потоком. От него могут порождаться другие потоки.

10. Диаграммы состояния потоков. Понятие контекста и переключения контекста.
	- Диаграммы состояния потоков
		- Состояния:
			- выполнения (выполняется процессором)
			- готовности к выполнению (готов и ждёт выделения процессорного времени)
			- ожидания наступления некоторого события (не претендует на процессорное время)
	  	- Переходы (только неочевидные)
			- выполнения -> готовности
				- при окончании кванта процессорного времени
				- при появлении более приоритетного потока
		  	- ожидание -> готовность
				- в системе происходит какое-то событие, наступление готорого ожидает поток
		  	- также поток может просто аварийно завершиться
  	- Понятие контекста и переключение контекста
		- Переключение контекста — в многозадачных ОС и средах — процесс прекращения выполнения процессором одной задачи (процесса, потока, нити) с сохранением всей необходимой информации и состояния, необходимых для последующего продолжения с прерванного места, и восстановления и загрузки состояния задачи, к выполнению которой переходит процессор. При переключении контекста потока переключается также контекст процесса, т.к. при переключении контекста потока меняется регистр CR3, отвечающий за адресное пространство (содержит физический адрес каталога страниц или таблицы указателей каталогов страниц).
		- Сохраняемая информация
			- регистры общего назначения
			- контекст состояния сопроцессора с плавающей точкой
			- регистры SSE, AVX (x86)
			- сегментные регистры (x86) (речь идёт о сегментах кода, данных и т.д.)
			- некоторые управляющие регистры
	  	- Структуры ядра ОС, связанные с каждым потоком
			- общая информация (pid, tid, ...)
			- состояние процесса/потока
			- права доступа
			- используемые ресурсы и блокировки
			- счётчики использованных ресурсов (например, таймер процессорного времени)
			- память процесса
	  	- Очень важно, при переключении контекста происходит
			- очистка конвейера команд и данных процессора
			- Очищается TLB (translation lookaside buffer), отвечающий за страничное отображение линейных адресов на физические
	  	- Типы переключения контекста
			- добровольное (поток сам решил приостановиться)
			- принудительное
				- ядро может отобрать управление, потому что кончился квант времени
				- выполнение блокирующего системного вызова, и ядро решает, что может отобрать управление
				- использование синхронизирующих примитивов ядра
				- явная приостановка при помощи системного вызова (sleep, wait, ...)

11. Многозадачность в ОС. Типы многозадачности. 
	- Многозадачность (multitasking) - свойство операционной системы или среды выполнения обеспечивать возможность параллельной (или псевдопараллельной) обработки нескольких задач. Истинная многозадачность операционной системы возможна только в распределённых вычислительных системах.
 	- Типы многозадачности
		- Существует два типа многозадачности: 
			- Процессная многозадачность (основанная на процессах — одновременно выполняющихся программах). Здесь программа — наименьший элемент управляемого кода, которым может управлять планировщик операционной системы. Более известна большинству пользователей (работа в текстовом редакторе и прослушивание музыки). 
			- Поточная многозадачность (основанная на потоках). Наименьший элемент управляемого кода — поток (одна программа может выполнять 2 и более задачи одновременно)
		- К псевдопараллельной многозадачности можно отвести следующие типы:
			- Простое переключение
   				- Загружает в память два или более приложения, но предоставляет процессорное время только основному. Для выполнения фонового приложения оно должно быть активизировано.
   				- Преимущества: Может использовать уже работающие программы без учета многозадачности. 
   				- Недостатки: Ограниченное взаимодействие между программами.
			- Совместная многозадачность (кооперативная):**
				- Задача выполняется после объявления готовности отдать процессорное время другим задачам (задачи сами определяют, когда передавать управление другим задачам). Приложение может захватить фактически столько процессорного времени, сколько оно считает нужным.
				- Преимущества: Упрощает программирование, отсутствие необходимости в защите данных. 
				- Недостатки: Затруднена реализация многозадачной архитектуры ввода-вывода. Если задача не передает управление, она может заблокировать систему, оставив остальные задачи без возможности на выполнение.
			- Вытесняющая многозадачность (приоритетная):**
   				- Операционная система передает управление от одной программы к другой по различным событиям (ОС сама определяет управление между задачами). Распределение процессорного времени осуществляется планировщиком процессов. К тому же каждой задаче может быть назначен пользователем или самой операционной системой определённый приоритет, что обеспечивает гибкое управление распределением процессорного времени между задачами.
				- Преимущества: Быстрый отклик на действия пользователя, полная реализация многозадачного ввода-вывода в ядре ОС.
   				- Недостатки: Требует дисциплины при написании кода, особые требования к реентерабельности и защите данных.
	- Прочее
		- Компьютерная программа в целом или её отдельная процедура называется реентерабельной (reentrant - повторно входимый), если она разработана таким образом, что одна и та же копия инструкций программы в памяти может быть совместно использована несколькими пользователями или процессами. При этом второй пользователь может вызвать реентерабельный код до того, как с ним завершит работу первый пользователь и это как минимум не должно привести к ошибке, а при корректной реализации не должно вызвать потери вычислений. 
			- Для обеспечения реентерабельности необходимо выполнение нескольких условий:
				- никакая часть вызываемого кода не должна модифицироваться;
				- вызываемая процедура не должна сохранять информацию между вызовами;
				- если процедура изменяет какие-либо данные, то они должны быть уникальными для каждого пользователя;
				- процедура не должна возвращать указатели на объекты, общие для разных пользователей.
		- Квантование означает, что каждому потоку система выделяет определенный интервал времени (квант), в течение которого процессор потенциально может выполнять код этого потока. По завершении выделенного кванта планировщик принудительно переключает процессор на выполнение другого готового потока (если, конечно, такой есть), переводя старый активный поток в состояние готовности. Это гарантирует, что ни один поток не захватит ЦП на непозволительно большое время (как было в более ранних системах с так называемой невытесняющей или кооперативной многозадачностью). 

12. Иерархия, приоритеты и планирование потоков. Динамические уровни приоритетов. 
	- Иерархия и приоритеты потоков:
		- Иерархия: Потоки часто группируются по уровням приоритета в зависимости от их важности и роли. Например, системные потоки могут иметь более высокий приоритет по сравнению с прикладными.
		- Приоритеты: Каждому потоку присваивается приоритет, который определяет его относительную важность и влияет на решение о том, какие потоки будут выполнены в первую очередь.
	- Планирование потоков
		- «циклическое планирование»: Одним из самых старых, простых, справедливых и наиболее часто используемых считается алгоритм циклического планирования. Каждому процессу назначается определенный интервал времени, называемый его квантом, в течение которого ему предоставляется возможность выполнения. Если процесс к завершению кванта времени все еще выполняется, то ресурс центрального процессора у него отбирается и передается другому процессу. Разумеется, если процесс переходит в заблокированное состояние или завершает свою работу до истечения кванта времени, то переключение центрального процессора на другой процесс происходит именно в этот момент. Недостаток: Если частые переключения (квант - 4мс, а время переключения равно 1мс), то происходит уменьшение производительности.
		- «приоритетное планирование»: Основная идея проста: каждому процессу присваивается значение приоритетности и запускается тот процесс, который находится в состоянии готовности и имеет наивысший приоритет. Даже если у персонального компьютера один владелец, на нем могут выполняться несколько процессов разной степени важности. Например, фоновому процессу, отправляющему электронную почту, должен быть назначен более низкий приоритет, чем процессу, воспроизводящему на экране видеофильм в реальном времени. Чтобы предотвратить бесконечное выполнение высокоприоритетных процессов, планировщик должен понижать уровень приоритета текущего выполняемого процесса с каждым сигналом таймера (то есть с каждым его прерыванием). Если это действие приведет к тому, что его приоритет упадет ниже приоритета следующего по этому показателю процесса, произойдет переключение процессов. Можно выбрать и другую альтернативу: каждому процессу может быть выделен максимальный квант допустимого времени выполнения. Когда квант времени будет исчерпан, шанс запуска будет предоставлен другому процессу, имеющему наивысший приоритет.
		- «кооперативное планирование»: Это такой алгоритм планирования, при котором процесс получает столько процессорного времени, сколько он считает нужным. Таким образом, все процессы делят процессорное время, периодически передавая управление следующей задаче.
	- Динамические уровни приоритетов: Некоторые системы поддерживают динамическое изменение приоритетов в зависимости от активности и состояния потоков. Например, при потреблении процессорного времени поток может повысить свой приоритет для более частого выполнения. Цель планирования потоков вполне очевидна — определение порядка выполнения потоков в условиях внешней или внутренней многозадачности. Однако способы достижения этой цели существенно зависят от типа ОС. В Windows каждый поток обладает динамическим приоритетом, который система может автоматически изменять для обеспечения отзывчивости и предотвращения голодания потоков. Динамический приоритет изначально совпадает с базовым приоритетом, и его система может повышать или понижать в зависимости от различных условий. Повышение приоритета происходит, например, при перемещении процесса на передний план, получении входных данных или выполнении условий ожидания. После повышения динамического приоритета система постепенно его уменьшает с течением времени. Этот механизм направлен на предотвращение инверсии приоритета и гарантирование эффективного использования процессорного времени

13. Синхронизация и взаимоблокировка ресурсов. Механизмы синхронизации.
	- Синхронизация
		- Ситуации, в которых два (и более) процесса считывают или записывают данные одновременно и конечный результат зависит от того, какой из них был первым, называются состояниями состязания.
		- Критическая область - часть программы, в которой есть обращение к совместно используемым данным.
		- Критический ресурс - ресурс, к которому осуществляется одновременный доступ.
		- Условия для эффективной совместной работы процессов
			- Два процесса не могут одновременно находиться в своих критических областях. 
			- Не должны выстраиваться никакие предположения по поводу скорости или количества центральных процессоров. 
			- Никакие процессы, выполняемые за пределами своих критических областей, не могут блокироваться любым другим процессом. 
			- Процессы не должны находиться в вечном ожидании входа в свои критические области.
		- Синхронизация - механизм упорядочивания выполнения программных блоков двух или более потоков.
			- Синхронизация предполагает наличие общей памяти. В случае потоков проблемы нет, так как потоки разделяют адресное пространство процесса. Но у процессов разобщенные адресные пространства, поэтому нужно найти какое-то решение.
				- Общие структуры хранятся в ядре, для доступа используются системные вызовы.
				- Совместно используемая память. 
				- Общий файл. 
		- В любом случае несколько процессов, использующих общее адресное пространство, никогда не будут столь же эффективными, как потоки, реализованные на пользовательском уровне, поскольку к управлению процессами неизменно привлекается ядро.
	- Механизмы синхонизации
		- Семафор - целочисленная переменная для подсчета количества активизаций, отложенных на будущее. Значение семафора может быть равно 0, что будет свидетельствовать об отсутствии сохраненных активизаций, или иметь какое-нибудь положительное значение, если ожидается не менее одной активизации.
		- Мьютекс - это совместно используемая переменная, которая может находиться в одном из двух состояний: заблокированном или незаблокированном. Следовательно, для их представления нужен только один бит, но на практике зачастую используется целое число, при этом нуль означает незаблокированное, а все остальные значения — заблокированное состояние. Упрощенная версия семафора.
		- Объект критического раздела обеспечивает синхронизацию, аналогичную той, которая предоставляется объектом мьютекса, за исключением того, что критический раздел может использоваться только потоками одного процесса. Объекты критических разделов нельзя совместно использовать в процессах.
		- Объект события - это объект синхронизации, состояние которого может быть явно задано с помощью функции SetEvent. Существуют два типа объекта события:
			- Событие сброса вручную: объект события, состояние которого остается сигнальным до тех пор, пока функция ResetEvent явно не будет сброшена на незначимую. Во время передачи сигнала можно освободить любое количество ожидающих потоков или потоков, которые впоследствии указывают один и тот же объект события в одной из функций ожидания. 
			- Событие автоматического сброса: объект события, состояние которого остается сигнальным до тех пор, пока не будет освобожден один поток ожидания, в этот момент система автоматически устанавливает состояние без знака. Если ожидающих потоков нет, состояние объекта события остается сигнальным. 
		- Заблокированные (Interlocked-) функции предоставляют простой механизм для синхронизации доступа к переменной, совместно используемой несколькими потоками. Эти функции являются атомарными по отношению к вызовам других взаимосвязанных функций. Они реализуется с помощью встроенной функции компилятора, где это возможно. Гарантируют неделимость выполнения операции, предотвращая переключение контекста между потоками.
		- Барьеры: используются для синхронизации группы потоков, ожидающих друг друга перед выполнением следующего этапа работы.
	- Взаимоблокировка ресурсов
		- Под ресурсом понимается все, что должно предоставляться, использоваться и через некоторое время высвобождаться, поскольку в один и тот же момент времени может использоваться только одним процессом. 
		- Взаимоблокировка в группе процессов возникает в том случае, если каждый процесс из этой группы ожидает события, наступление которого зависит исключительно от другого процесса из этой же группы. Поскольку все процессы находятся в состоянии ожидания, ни один из них не станет причиной какого-либо события, которое могло бы возобновить работу другого процесса, принадлежащего к этой группе, и ожидание всех процессов становится бесконечным.
		- Ресурсной взаимоблокировкой называется такой вид взаимоблокировки, когда событием, наступления которого ожидает каждый процесс, является высвобождение какого-либо ресурса, которым на данный момент владеет другой участник группы.

14. Взаимоблокировка ресурсов в многозадачных системах. Решение задачи взаимоблокировки ресурсов. 
	- Взаимоблокировка в группе процессов возникает в том случае, если каждый процесс из этой группы ожидает события, наступление которого зависит исключительно от другого процесса из этой же группы. для возникновения ресурсных взаимоблокировок должны выполняться четыре условия: 
		1. Условие взаимного исключения. Каждый ресурс либо выделен в данный момент только одному процессу, либо доступен. 
		2.  Условие удержания и ожидания. Процессы, удерживающие в данный момент ранее выделенные им ресурсы, могут запрашивать новые ресурсы. 
		3.  Условие невыгружаемости. Ранее выделенные ресурсы не могут быть принудительно отобраны у процесса. Они должны быть явным образом высвобождены тем процессом, который их удерживает. 
		4.  Условие циклического ожидания. Должна существовать кольцевая последовательность из двух и более процессов, каждый из которых ожидает высвобождения ресурса, удерживаемого следующим членом последовательности.
	- Решение задачи взаимоблокировки ресурсов 
		- Чаще всего для борьбы с взаимными блокировками используются четыре стратегии: 1. Игнорирование проблемы. Может быть, если вы проигнорируете ее, она проигнорирует вас.
		- Обнаружение и восстановление. Дайте взаимоблокировкам проявить себя (не блокировать сразу же), обнаружьте их и выполните необходимые действия.
		- Динамическое уклонение от них за счет тщательного распределения ресурсов.
		- Предотвращение за счет структурного подавления одного из четырех условий, необходимых для их возникновения (одного из 4 которые описаны выше).

15. Компьютерное время. Ожидаемые таймеры.
	- Компьютерное время
		- Определение секунды в Международной системе единиц (СИ) основано на периодах колебания атома цезия-133 .
		- Международное атомное время (TAI, фр. Temps Atomique International) — время, в основу измерения которого положены электромагнитные излучения, излучаемые атомами или молекулами при переходе из одного энергетического состояния в другое.
		- Всемирное время (UT) – имеет несколько версий стандарта, базируется на вращении Земли относительно далёких объектов.
		- UT1, или универсальное время — основная версия всемирного времени. UT1 вычисляется пропорционально углу вращения Земли относительно международной небесной системы координат (ICRS).
		- UTC – атомная шкала времени, аппроксимирующая UT1. Это международный стандарт, на котором базируется время часовых поясов. В UTC в качестве единицы времени используется секунда СИ, поэтому UTC идёт синхронно с международным атомным временем (TAI). Для синхронизации с UT1 используется секунда синхронизации, которая прибавляется или вычитается по мере необходимости
		- Локальное (местное) время служит для того, чтобы солнечный день приходился приблизительно на один и тот же промежуток времени.
		- Unix-время (также POSIX-время) — система описания моментов во времени, принятая в Unix и других POSIX-совместимых операционных системах [3]. Определяется как количество секунд, прошедших с полуночи (00:00:00 UTC) 1 января 1970 года; этот момент называют эпохой Unix.
		- Время Windows — это количество времени в миллисекундах, прошедшее с момента последнего запуска системы.
		- Время прерывания - это время с момента последнего запуска системы в интервалах по 100 нс. 
		- WinAPI
			- GetTickCount[64] – количество миллисекунд с момента запуска системы
			- GetSystemTimeAsFileTime - Извлекает текущую системную дату и время (FILETIME)
			- GetSystemTimePreciseAsFileTime - извлекает текущую системную дату и время с максимально возможной точностью (<1 мкс) (FILETIME)
			- Get(/Set)TimeZoneInformation - Текущие параметры часового пояса (TIME_ZONE_INFORMATION)
			- GetLocalTime – Извлекает текущую локальную дату и время(SYSTMEEMTIME)
			- GetSystemTime – текущее время UTC (SYSTEMTIME)
			- структура SYSTEMTIME: можно получить конкретные значения от мс до года
			- структура FILETIME: 64-разрядное значение (нужно использовать FileTimeToSystemTime)
		- POSIX API
			- структура time_t – хранит количество секунд, прошедших с начала эпохи, каждый 4й год високосный (!)
			- структура tm - Для более удобного представления календарного времени (от с до года, день недели и года, летнее время)
			- time_t time(time_t*) - текущее время
			- tm *localtime(const time_t *) - местное время из time_t
			- tm *gmtime(const time_t *) - UTC время
			- time_t mktime(tm *) - из tm в time_t
			- char *asctime(const  tm *) - в строку
			- char *ctime(const time_t *) - в строку
			- strftime - из tm  форматированную строку
		- Часы LINUX: Ядро таймеров POSIX.1b представляет собой набор часов, которые используются как привязка ко времени. 
			- CLOCK_REALTIME: общесистемные часы реального времени (для абсолютного ожидания);
			- CLOCK_MONOTONIC: время непрерывной работы системы (для относительного времени ожидания, периодических задач);
			- CLOCK_PROCESS_CPUTIME_ID: часы, измеряющие время работы процесса;
			- CLOCK_THREAD_CPUTIME_ID: часы, измеряющие время работы текущего потока;
		- Системное Время:
			- Системный таймер служит для отслеживания хода времени ядром: это обеспечение механизма управления прерываниями, которые возникают периодически с постоянной частотой   
			- Real-Time Clock (ЧРВ): электронная схема, предназначенная для учёта хронометрических данных (текущее время, дата, день недели и др.), представляет собой систему из автономного источника питания и учитывающего устройства.
	- Ожидаемые таймеры
		- Объект таймера ожидания — это объект синхронизации, состояние которого по достижении указанного срока устанавливается в значение Signaled. Существует два типа таймеров ожидания, которые можно создать: сброс вручную и синхронизация. Таймер любого типа также может быть периодическим. 
			- Таймер сброса вручную - Таймер, состояние которого остается сигнальным до вызова SetWaitableTimer, чтобы установить новое время выполнения. 
			- Таймер синхронизации - Таймер, состояние которого остается сигнальным до тех пор, пока поток не завершит операцию ожидания в объекте таймера. 
			- Периодический таймер - Таймер, который повторно активируется каждый раз, когда истечет указанный период, пока таймер не будет сброшен или отменен. 
		- Поток использует функцию CreateWaitableTimer или CreateWaitableTimerEx для создания объекта таймера. Поток создания указывает, является ли таймер таймером сброса вручную или таймером синхронизации. Создающий поток может указать имя объекта таймера. Потоки в других процессах могут открывать дескриптор для существующего таймера, указывая его имя в вызове функции OpenWaitableTimer. Поток вызывает функцию SetWaitableTimer для активации таймера. Поток может использовать функцию CancelWaitableTimer для установки таймера в неактивное состояние. Чтобы сбросить таймер, вызовите SetWaitableTimer. Завершив работу с объектом таймера, вызовите CloseHandle, чтобы закрыть дескриптор для объекта таймера.
		
16. Управление памятью: адресное пространство процесса, организация памяти, основные механизмы управления памятью, концепция рабочего множества. 
	- Адресное пространство процесса
		- Адресное пространство — это набор адресов, который может быть использован процессом для обращения к памяти
		- У каждого процесса имеется собственное адресное пространство, независимое от того адресного пространства, которое принадлежит другим процессам (за мааленькими исключениями)
		- Адресное пространство процесса состоит из диапазона адресов, которые выделены процессу, и, что более важно, в этом диапазоне выделяются адреса, которые процесс может так или иначе использовать. Каждому процессу выделяется "плоское" 32- или 64-битовое адресное пространство. Термин "плоское" обозначает, что адресное пространство состоит из одного диапазона адресов (например, 32-разрядное адресное пространство занимает диапазон адресов от 0 до 429496729)
		- Секции памяти
			- код
			- данные (инициализированные переменные)
			- неинициализированные глобальные переменные
			- стек процесса пространства пользователя (не путать со стеком процесса в пространстве ядра, который управляется и используется ядром)
			- доп. сегменты каждой библиотеки, загружаемой в адресное пространство процесса
			- все file mappingи
			- все области совместно используемой памяти
			- все анонимные отображения в память
	- Организация памяти
		- Физические адреса — это реальные адреса, используемые для выбора микросхем физической памяти, содержащих данные. Физическая память организована в виде последовательности 8-разрядных байтов. Каждому байту присвоен уникальный адрес
		- Модели доступа к памяти
			- плоская
			- сегментированная
			- модель режима реального адреса
	  	- ![модели доступа к памяти](модели_доступа_к_памяти.png)
	- Основные механизмы управления памятью
		- Свопинг - процесс выгружается и загружается в ОЗУ полностью. Используются списки занятых и незанятых сегментов памяти
			- первое подходящее (ищет первый подходящий незанятый сегмент нужного размера)
			- следующее подходящее (то же самое, но при следующем поиске начинает искать оттуда, где остановился в прошлый раз, а не с самого начала)
			- наиболее подходящее (ищет самый маленький сегмент из подходящих)
			- наименее подходящее (ищет самый большой сегмент, чтобы наверняка)
			- быстро искомое подходящее (использует отдельные списки для самых востребованных размеров сегментов)
	  	- Виртуальная память - разбиение всей памяти на страницы фиксированного размера с непрерывным множеством адресов, выделение процессу памяти страницами
			- Диспетчер памяти - аппаратный компонент компьютера, который обрабатывает все операции с памятью и кэшированием, связанные с процессором.
			Виртуальные адреса не выставляются напрямую на шине памяти. Вместо этого они поступают в диспетчер памятиВиртуальные адреса не выставляются напрямую на шине памяти. Вместо этого они поступают в диспетчер памяти, который отображает вирутальные адреса на реальные
			- Работа MMU
				- аппаратное управление памятью (контроль и регуляция использования процессором ОЗУ и кеша)
				- управление памятью ОС (обеспечение наличия достаточного количества памяти у процессов)
				- управление памятью приложений (выделение памяти процессам и переиспользование её после того, как процесс завершается)
  			- Типы памяти
				- Логическая (виртуальная)
				- Физическая (реальная)
  			- Таблицы страниц используются для отображения виртуальных страниц на страничные блоки
				- Запись состоит из номера страничного блока (вроде это реальный адрес страницы), бита присутствия/отсутствия (в реальной памяти), битов защиты (например, на чтение, запись, исполнение), бита изменения (имеет значение, когда ОС решает восстановить страницу. Если она не изменялась, то он страницы можно просто отказаться, потому что последняя версия и так лежит на диске) и бита ссылки (помогает ОС выбрать отселяемую страницу при возникновении ошибки отсутствия страницы. Если к странице не было обращений, её можно смело выкидывать).
  			- Буферы быстрого преобразования адреса (Translation Lookaside Buffer, TLB) используются для ускоренного доступа к часто используемым страницам и хранят их. Если при попытке найти нужную страницу в TLB её там нет, происходит поиск в обычной таблице страниц, и страница помещается в TLB. TLB - аппаратное решение
				- Ошибки отсутствия записей
					- программная (страница есть в памяти, но не в TLB, нужно просто обновить TLB)
					- аппаратная (страницы нет ни в памяти, ни в TLB, ошибка обрабатывается в миллион раз медленнее программной)
  			- Таблицы страниц для больших объёмов памяти
				- подход первый: многоуровневая таблица ![3.1.7](3.1.7.png)
				- подход второй: инвертированные таблицы (одна запись для каждого страничного блока в реальной памяти, а не для каждой страницы в вируальном пространстве. Экономит много места, но сильно усложняет преобразование виртуальных адресов в реальные, потому что теперь нужно просматривать всю таблицу для поиска нужной страницы. Решается использованием TLB и хеш-таблиц)
	- Концепция рабочего множества
		- Рабочий набор процесса — это набор страниц в виртуальном адресном пространстве процесса, которые в настоящее время находятся в физической памяти. Рабочий набор содержит только страничные выделения памяти. В рабочий набор не включаются ресурсы памяти, не допускающие подкачку, такие как расширения адресных окон (AWE) или большие страницы
		- Если процесс ссылается на страницу памяти, которая в настоящее время не входит в рабочий набор, происходит ошибка страницы. Обработчик ошибки системной страницы пытается устранить ошибку страницы, и в случае успеха страница добавляется в рабочий набор
		- Ошибка жесткой страницы должна быть устранена путем чтения содержимого страницы из резервного хранилища страницы, которое является системным файлом подкачки или файлом, сопоставленным в памяти, созданным процессом. Ошибка мягкой страницы может быть устранена без доступа к резервному хранилищу. Ошибка мягкой страницы возникает в следующих случаях:
			- Страница находится в рабочем наборе какого-то другого процесса, поэтому она уже находится в памяти.
			- Страница находится в состоянии перехода, так как она либо была удалена из рабочих наборов всех процессов, которые использовали страницу и еще не была перепрофилирована, либо она уже находится в результате операции предварительной выборки диспетчера памяти.
			- Процесс впервые ссылается на выделенную виртуальную страницу (иногда это называется ошибкой с нулевым спросом)
		- Страницы можно удалить из рабочего набора в следующих случаях:
			- процесс уменьшает свой рабочий набор явно при помощи, например, SetWorkingSetSize
			- процесс отменяет представление файла
			- диспетчер памяти проводит обрезание рабочего набора
			- диспетчер памяти должен заменить существующую страницу другой, например, из-за того, что текущий рабочий набор уже имеет максимальный размер

17. Классификация запоминающих устройств. Иерархия памяти. Оперативные и постоянные запоминающие устройства.
	- Классификация ЗУ
 		- Запоминающее устройство — носитель информации, предназначенный для записи и хранения данных. В основе работы запоминающего устройства может лежать любой физический эффект, обеспечивающий приведение системы к двум или более устойчивым состояниям. 
		- Классификация запоминающих устройств по устойчивости записи и возможности перезаписи: 
			- Постоянные (ПЗУ), содержание которых не может быть изменено конечным пользователем (например, BIOS). ПЗУ в рабочем режиме допускает только считывание информации. 
			- Записываемые (ППЗУ), в которые конечный пользователь может записать информацию только один раз (например, CD-R). 
			- Многократно перезаписываемые (ПППЗУ) (например, CD-RW). 
			- Оперативные (ОЗУ) — обеспечивают режим записи, хранения и считывания информации в процессе её обработки. Информация исчезает после отключения от источника питания (например, тока). 
		- По типу доступа ЗУ делятся на: 
			- устройства с последовательным доступом (например, магнитные ленты). 
			- устройства с произвольным доступом (RAM) (например, оперативная память). 
			- устройства с прямым доступом (например, жесткие магнитные диски). 
			- устройства с ассоциативным доступом (специальные устройства, для повышения производительности БД) 
		- Классификация запоминающих устройств по геометрическому исполнению: 
			- дисковые (магнитные диски, оптические, магнитооптические); 
			- ленточные (магнитные ленты, перфоленты); 
			- барабанные (магнитные барабаны); 
			- карточные (магнитные карты, перфокарты, флэш-карты, и др.) 
			- печатные платы (карты DRAM). 
		- Классификация запоминающих устройств по физическому принципу: 
			- перфорационные (перфокарта; перфолента); 
			- с магнитной записью (ферритовые сердечники, магнитные диски, магнитные ленты, магнитные карты); 
			- оптические (CD, DVD, HD-DVD, Blu-ray Disc); 
			- использующие эффекты в полупроводниках (флэш-память) и другие
	- Иерархия памяти
 		- Современная система памяти образует иерархию от быстрых типов памяти маленького размера ("вверху") до медленных типов памяти большого размера ("внизу").
		- Конкретный уровень иерархии кэширует или является кэшем для данных, расположенных на более низком уровне. Когда процессор хочет получить какие-то данные, он их сперва ищет на самых быстрых высоких уровнях. И спускается на более низкие (более медленные), если не может найти.
			- несколько регистров процессора (0 тактов)
			- несколько КБ кэш-памяти 1-го уровня (4 такта)
			- пара сотен КБ кэш-памяти 2-го уровня (10)
			- несколько МБ кэш-памяти 3-го уровня (50)
			- оперативная память (200)
			- буфер диска (100'000)
			- локальный диск (10 млн)
			- удалённые сервера (1 млрд)
		- Резервные копии данных можно хранить на магнитных лентах.
	- ПЗУ, ОЗУ
		- ПЗУ - это место в компьютере, где хранятся важные программы, например, управление процессором, программы для запуска и выключения компьютера, а также тестовые программы для проверки работы различных блоков. Он также содержит информацию о том, где находится операционная система на диске.
		- ОЗУ - это место, где компьютер хранит данные и команды, которые ему нужны в данный момент для выполнения операций. ОЗУ передает данные процессору, обычно через кэш-память. Каждая ячейка в ОЗУ имеет свой уникальный адрес. Устанавливается в виде модулей объемом до 64 ГБ, таких как DIMM, и использует разные поколения DDR-памяти, которые отличаются по быстродействию и другим характеристикам.

18. Виртуальная память. Структуризация адресного пространства виртуальной памяти. Задачи управления виртуальной памятью.
	- Виртуальная память
		- Физические адреса являются конкретными и окончательными — без трансляции, без подкачки, без проверки привилегий. Вы выставляете их на шину и всё: выполняется чтение или запись. Однако в современной операционной системе программы используют абстракцию — виртуальное адресное пространство. Каждая программа пишется в такой модели, что она выполняется одна, всё пространство принадлежит ей, код использует адреса логической памяти, которые должны быть преобразованы в физические адреса до того, как будет выполнен доступ к памяти. Логический адрес на x86 состоит из двух частей: селектора сегмента и смещения внутри сегмента. Процесс трансляции включает два шага: 
			- учёт сегментного селектора и переход от смещения внутри сегмента к некоторому линейному адресу;
			- перевод линейного адреса в физический.
	- Структуризация адресного пространства виртуальной памяти
		- Режимы адресации
			- реальный (сначала вы устанавливаете сегментный регистр, по сути говоря «так, я хочу работать с куском памяти начиная с адреса X»; затем 16-битный адрес уже используется как смещение в рамках этого куска)
			- защищённый (также используется сегментированная модель памяти, однако уже организованная по другому принципу: расположение сегментов описывается специальными структурами (таблицами дескрипторов), расположенными в оперативной памяти. Эти таблицы: глобальная и локальная (Global/Local Descriptor Table))
			- длинный (нет сегментации, большинство сегментных регистров устанвливаются в 0, не используется таблица LDT, но используется GDT)
	  	- Там что-то про кольца, но я его трубу шатал это переписывать, если честно
		- Ставится задача транслировать 48-битный виртуальный адрес в физический. Она решается аппаратным обеспечением — блоком управления памятью (memory management unit, MMU). Этот блок является частью процессора. Чтобы транслировать адреса, он использует структуры данных в оперативной памяти, называемые таблицами страниц. Вместо двухуровневой системы таблиц страниц, используемой системами с 32-битной архитектурой x86, системы, работающие в длинном режиме, используют четыре уровня таблицы страниц
		- Наиболее часто используемые размеры страниц:
			- 4кб
			- 2мб
			- 1гб
	  	- Пусть для определённости размер страницы равен 4 КБ. Значит, младшие 12 битов адреса кодируют смещение внутри страницы и не изменяются, а старшие биты используются для определения адреса начала страницы
	- Задачи управления виртуальной памятью
		- размещает данные в запоминающих устройствах разного типа, например, часть программы в оперативной памяти, а часть на диске;
		- перемещает по мере необходимости данные между запоминающими устройствами разного типа, например, подгружает нужную часть программы с диска в оперативную память;
		- преобразует виртуальные адреса в физические.
		- Операционные системы используют различные алгоритмы для определения, какие страницы данных должны быть выгружены из оперативной памяти, чтобы освободить место для других данных (LRU)
		*Все эти действия выполняются автоматически*

19. Подкачка. Алгоритмы замещения страниц. Куча (heap). Стек.
	- Подкачка
		- Файл подкачки или виртуальная память — это способ системы виртуальной памяти увеличить оперативную память, когда ее не хватает для совершения операций. Система автоматически задействует файл подкачки, когда приложениям не хватит системной памяти ОЗУ
		- Страничная память - реализации виртуальной памяти, при которой физическая память и адресное пространство разбивается на блоки (страницы), а также осуществляется страничный свопинг.
		- Единицей управления памятью является страница, и почти все компоненты управления памятью работают с точностью до страниц.
		- Swapping (или «подкачка памяти») — это процесс, при котором страница памяти копируется в специальное пространство на жестком диске, называемое пространством подкачки (англ. «swap space»), освобождая занимаемый ею объем оперативной памяти.
			- Linux:
			- В Linux подкачка реализуется через механизм swap-раздела (swap partition: раздел жесткого диска, используемый исключительно для подкачки памяти; никакие другие файлы не могут находиться там) либо файла (swap file: специальный файл, который находится среди остальных файлов вашей файловой системы).
			- Если система обнаруживает, что в оперативной памяти недостаточно места для хранения всех активных процессов, она начинает перемещать части неиспользуемых данных на swap-раздел.
			- Swap-раздел может быть создан на жестком диске, и он предоставляет дополнительное пространство для хранения страниц памяти, которые временно не нужны.
			- Когда данные необходимы, они могут быть восстановлены из swap-раздела обратно в оперативную память.
		- Windows:
			- В Windows подкачка реализуется с использованием файла подкачки (pagefile).
			- Аналогично Linux, если оперативной памяти недостаточно, Windows перемещает неиспользуемые данные на файл подкачки.
			- Windows поддерживает до 16 файлов подкачки. Обычно они распределены по нескольким дискам (для повышения производительности ввода-вывода). Все файлы имеют некий начальный размер и максимальный размер (до которого они могут увеличиться при необходимости).
			- Windows использует алгоритмы замещения страниц для определения, какие данные следует перемещать на файл подкачки и какие - обратно в оперативную память.
	- Алгоритмы замещения страниц — это алгоритмы, используемые операционной системой для принятия решения о том, какие страницы памяти следует выгрузить на долгосрочное хранилище (например, в файл подкачки) при нехватке оперативной памяти
		- Оптимальный алгоритм замещения страниц
			- это идеальный алгоритм, который всегда выбирает страницу для замещения, которая не будет использована в течение самого долгого времени. Однако он трудно реализуем из-за невозможности предвидения будущего использования страниц.
		- Использование битов состояния в алгоритмах исключения страниц
			- многие алгоритмы используют биты состояния (например, биты "использования" R (при обращении к странице) и "модификации" M (при модификации)) для принятия решения о том, какие страницы следует замещать. Время от времени (например, при каждом прерывании по таймеру) бит R сбрасывается.
			- Страницы делятся на 4 класса в зависимости от комбинаций значений R и M (классы 0: 00, 1: 01, 2: 10, 3: 11).
		- Алгоритм исключения давно использовавшейся страницы (Not Recently Used)
			- замещает произвольную страницу, относящуюся к самому низкому непустому классу.
		- Алгоритм «первой пришла, первой и ушла» (FIFO)
			- замещает страницу, которая находится в памяти дольше всего. Использует принцип очереди: первая загруженная страница первой выгружается.
		- Алгоритм «второй шанс»
			- Простой модификацией алгоритма FIFO, исключающей проблему удаления часто запрашиваемой страницы, может стать проверка бита R самой старой страницы. Если его значение равно нулю, значит, страница не только старая, но и невостребованная, поэтому она тут же удаляется. Если бит R имеет значение 1, он сбрасывается, а страница помещается в конец списка страниц и время ее загрузки обновляется, как будто она только что поступила в память. Затем поиск продолжается.
		- Алгоритм «часы»
			- При возникновении ошибки отсутствия страницы проверяется та страница, на которую указывает стрелка. Если ее бит R имеет значение 0, страница выселяется, на ее место в «циферблате» вставляется новая страница и стрелка передвигается вперед на одну позицию. Если значение бита R равно 1, то он сбрасывается и стрелка перемещается на следующую страницу.
		- Алгоритм замещения наименее востребованной страницы (Least Recently Used)
			- при возникновении ошибки отсутствия страницы нужно избавиться от той страницы, которая длительное время не была востребована.
		- Алгоритм нечастого востребования (NFU - Not Frequently Used)
			- замещает страницу, которая редко запрашивается. Подсчитывает частоту использования каждой страницы (на прерывания таймера добавляет к счётчикам страниц значение R) и выбирает ту, которая использовалась наименее часто.
		- Алгоритм старения (Aging)
  			- небольшая модификация алгоритма NFU позволяет довольно близко подойти к имитации алгоритма LRU. Модификация состоит из двух частей. Во-первых, перед добавлением к счетчикам значения бита R их значение сдвигается на один разряд вправо. Во-вторых, значение бита R добавляется к самому левому, а не к самому правому биту.
		- Алгоритм «рабочий набор»
			- при возникновении ошибки отсутствия страницы нужно выселить ту страницу, которая не относится к рабочему набору. Для реализации подобного алгоритма нам необходим четкий способ определения того, какие именно страницы относятся к рабочему набору. По определению рабочий набор — это набор страниц, используемых в k самых последних обращений.
		- Алгоритм WSClock (Working Set Clock)
  			- как алгоритм «часы», но также учитывает "возраст" (сравнивает с некоторым t).
			- Если возраст страницы превышает значение t и страница не изменена, она не относится к рабочему набору и ее точная копия присутствует на диске - тогда страничный блок просто истребуется. Если изменена, то планируется запись на диск (для следующего обхода). Если при завершении обхода ничего не запланировано, то истребуется любая неизменённая страница. Иначе в качестве жертвы выбирается текущая страница (памянем...).
	- Куча (heap) — это сегмент памяти, для которого не устанавливается постоянный размер перед компиляцией и который может динамически управляться программистом. То есть, это «свободный пул» памяти, который можно использовать при запуске приложения. Размер кучи приложения определяется физическими ограничениями оперативной памяти (оперативной памяти) и обычно намного больше размера стека. Память из кучи выделяется с помощью функции malloc(). malloc возвращает указатель void, который затем нужно привести к правильному типу. После использования блока памяти его нужно освободить помощью функции free().
		- Каждый процесс имеет кучу по умолчанию, предоставляемую системой. Приложения, которые часто выделяют ресурсы из кучи, могут повысить производительность с помощью частных куч. 		- Частная куча — это блок одной или нескольких страниц в адресном пространстве вызывающего процесса. После создания частной кучи процесс использует такие функции, как HeapAlloc и HeapFree, для управления памятью в этой куче. Функции кучи также можно использовать для управления памятью в куче процесса по умолчанию с помощью дескриптора, возвращаемого функцией GetProcessHeap.
		- После фиксации страницы не удаляются до завершения процесса или до тех пор, пока куча не будет уничтожена путем вызова функции HeapDestroy.
  		- WinAPI:
			- HeapCreate - Создание частного объекта кучи 
			- HeapAlloc - Выделение указанного количества байтов из частной кучи
			- HeapFree - Освобождение ранее выделенного блока памяти
			- HeapDestroy - Уничтожение частного объекта кучи
			- HeapSize, HeapReAlloc, HeapValidate - Предоставление информации о размере памяти, перераспределение блока и проверка допустимости памяти
	- Стек — это сегмент памяти, в котором данные, такие как локальные переменные и вызовы функций, добавляются и/или удаляются по принципу «последним пришел — первым вышел» (LIFO). 
		- Вообще говоря, стек — это структура данных, которая хранит значения данных в памяти последовательно. Однако, в отличие от массива, вы получаете доступ (чтение или запись) к данным только на «верхней части» стека. Чтение из стека называется «извлечение» (pop), а запись в стек — «вталкивание» (push).
		- На текущую вершину стека указывает регистр esp. Стек «растет» вниз, от верхних адресов памяти к младшим.
		- STDCALL — это стандартное соглашение для Win32 API. В данном соглашении, аргументы передаются справа налево и очистка стека ложится на вызываЕМУЮ функцию. Для передачи аргументов используется стек, т.е. перед вызовом нужно положить аргументы на стек. Возвращаемое значение записывается в регистр eax.

20. Типы устройств ввода/вывода. Обработка внешних прерываний. Синхронный и асинхронный ввод/вывод. 
	- Типы устройств ввода-вывода
		- К блочным относятся такие устройства, которые хранят информацию в блоках фиксированной длины, у каждого из которых есть собственный адрес. Вся передача данных ведется пакетами из одного или нескольких целых (последовательных) блоков. Важным свойством блочного устройства является то, что оно способно читать или записывать каждый блок независимо от всех других блоков. Среди наиболее распространенных блочных устройств жесткие диски, приводы оптических дисков и флеш-накопители USB.
		- Другой тип устройств ввода-вывода — символьные устройства. Они выдают или воспринимают поток символов, не относящийся ни к какой блочной структуре. Они не являются адресуемыми и не имеют никакой операции позиционирования. В качестве символьных устройств могут рассматриваться терминалы, принтеры, сетевые интерфейсы, мыши (в качестве устройства-указателя) и множество других устройств, не похожих на дисковые устройства.
	- Обработка внешних прерываний
		- На аппаратном уровне прерывания работают следующим образом. Когда устройство ввода-вывода заканчивает свою работу, оно инициирует прерывание (при условии, что прерывания разрешены операционной системой). Для этого устройство выставляет сигнал на выделенную устройству специальную линию шины. Этот сигнал распознается микросхемой контроллера прерываний, расположенной на материнской плате. Контроллер прерываний принимает решение о дальнейших действиях
		- При отсутствии других необработанных запросов прерывания контроллер прерываний обрабатывает прерывание немедленно. Если прерывание уже обрабатывается, и в это время приходит запрос от другого устройства по линии с более низким приоритетом, то новый запрос просто игнорируется.
		- Для обработки прерывания контроллер выставляет на адресную шину номер устройства, требующего к себе внимания, и устанавливает сигнал прерывания на соответствующий контакт процессора.
		- Этот сигнал заставляет процессор приостановить текущую работу и начать выполнять обработку прерывания. Номер, выставленный на адресную шину, используется в качестве индекса в таблице, называемой вектором прерываний
		- Вскоре после начала своей работы процедура обработки прерываний подтверждает получение прерывания, записывая определенное значение в порт контроллера прерываний. Это подтверждение разрешает контроллеру издавать новые прерывания. Благодаря тому, что центральный процессор откладывает выдачу подтверждения до момента, когда он уже готов к обработке нового прерывания, удается избежать ситуации состязаний при появлении почти одновременных прерываний от нескольких устройств
		- Аппаратура всегда, прежде чем начать процедуру обработки прерывания, со-храняет определенную информацию. Сохраняемая информация и место ее хранения широко варьируются в зависимости от центрального процессора. Как минимум сохраняется счетчик команд, что позволяет продолжить выполнение прерванного процесса. Другая крайность представляет собой сохранение всех программно доступных регистров и большого количества внутренних регистров центрального процессора.
	- Синхронный и асинхронный ввод-вывод
		- Асинхронный ввод-вывод (I/O) используется для оптимизации производительности приложений. В отличие от синхронного ввода-вывода, где приложение блокируется во время операции, асинхронный подход позволяет приложению продолжать выполнение, пока операция I/O выполняется.
		- По умолчанию все файловые дескрипторы в Unix-системах создаются в «блокирующем» режиме.
		- Существует два различных, но взаимодополняющих способа устранить блокировки:
			- неблокирующий режим ввода-вывода
				- Файловый дескриптор помещают в “неблокирующий” режим, добавляя флаг O_NONBLOCK к существующему набору флагов дескриптора с помощью fcntl:
					```
					/* Добавляем флаг O_NONBLOCK к дескриптору fd */ 
					const int flags = fcntl(fd, F_GETFL, 0); 
					fcntl(fd, F_SETFL, flags | O_NONBLOCK);
					```
				- С момента установки флага дескриптор становится неблокирующим
				- Недостатки: пустая трата процессорного времени
			- мультиплексирование с помощью системного API, такого как select либо epoll
				- Существует несколько мультиплексирующих системных вызовов:
					- Вызов select существует во всех POSIX-совместимых системах, включая Linux и MacOSX
					- Группа вызовов epoll_* существует только на Linux
					- Группа вызовов kqueue существует на FreeBSD и других *BSD
			  	- Все три варианта реализуют единый принцип: делегировать ядру задачу по отслеживанию прихода данных для операций чтения/записи над множеством файловых дескрипторов. Все варианты могут заблокировать выполнение, пока не произойдёт какого-либо события с одним из дескрипторов из указанного множества
			  	- Все мультиплексирующие системные вызовы, как правило, работают независимо от режима файлового дескриптора (блокирующего или неблокирующего). Программист может даже все файловые дескрипторы оставить блокирующими, и после select либо epoll возвращённые ими дескрипторы не будут блокировать выполнение при вызове read или write, потому что данные в них уже готовы. 

21. Файловые системы. Файлы и директории. Управление внешней памятью. 
	- Файловые системы
		- Файловая система (file system) — порядок, определяющий способ организации, хранения и именования данных на носителях информации в компьютерах, а также в другом электронном оборудовании: цифровых фотоаппаратах, мобильных телефонах и т. п. Файловая система определяет формат содержимого и способ физического хранения информации, которую принято группировать в виде файлов. Конкретная файловая система определяет размер имен файлов (и каталогов), максимальный возможный размер файла и раздела, набор атрибутов файла. Некоторые файловые системы предоставляют сервисные возможности, например, разграничение доступа или шифрование файлов.
		- Файловые системы Linux
  			- Список файловых систем, которые поддерживаются ядром, находится в файле /proc/filesystems.
	 			- Виды файловых систем, предлагаемых при установке ОС на базе Linux: Ext, Ext2, Ext3, Ext4, JFS, XFS, Btrfs, Swap.
				- Linux поддерживает несколько десятков файловых систем при помощи уровня виртуальной файловой системы Virtual File System (VFS).
				- VFS определяет набор основных абстракций файловой системы и разрешенные с этими абстракциями операции. Системные вызовы обращаются к структурам данных VFS, определяют тип файловой системы (к которой принадлежит нужный файл) и при помощи хранящихся в структурах данных VFS указателей на функции запускают соответствующую операцию в указанной файловой системе. Является "абстрактным классом" для прочих файловых систем. Определяет методы open, write, read, 
				- Абстракции файловой системы в VFS:
					- Суперблок - критичная информация о компоновке файловой системы. Разрушение суперблока делает файловую систему нечитаемой. Хранится в первом блоке каждой группы блоков (кроме группы 1, где там загрузочная запись). 1КБ. определяет размер файловой системы, максимальное число файлов в разделе, объем свободного пространства, где искать незанятые участки. При выключении системы суперблок обязательно должен быть записан на диск.
					- i-узел (inode) - описывает один файл, каталог или устройство. Каждому файлу на диске соответствует один и только один индексный дескриптор файла, который идентифицируется своим порядковым номером - индексом файла (inode). Число файлов, которые могут быть созданы в файловой системе, ограничено числом индексных дескрипторов. Индексный дескриптор содержит информацию о типе файла, правах доступа, владельце, размере, времени доступа и других атрибутах.
					- Элемент каталога (dentry) - представляет собой элемент каталога. Кэшируются в dentry_cache для улучшения производительности. объект dentry не соответствует какой бы то ни было структуре данных на жестком диске. VFS создает эти объекты на лету на основании строкового представления имени пути.
					- Файл (file) - представляет собой открытый файл в памяти. Создается при системном вызове open и поддерживает операции чтения, записи, блокировки и другие.
			- EXT2 (Second Extended File System):
   				- Вторая расширенная файловая система, созданная для преодоления ограничений файловой системы EXT.
				- Отсутствие журналирования.
				- Размер файла до 2 ТБ.
					- Размер ФС до 32 ТБ.
			- EXT3 (Third Extended File System):
				- Поддерживает журналирование (быстрее восстановление).
				- Размер файла до 2 ТБ.
					- Размер ФС до 32 ТБ.
			- EXT4 (Fourth Extended File System):
   				- Поддерживает журналирование.
	   				- Введены новые функции (Экстенты, обратная совместимость, постоянное предварительное выделение, отложенное выделение, неограниченное количество подкаталогов, контрольная сумма журнала, более быстрая проверка FS, прозрачное шифрование).
				- Размер файла до 16 ТБ.
					- Размер ФС до 1 ЭксаБ (10^18 <- 2^60), но реальный меньше. Более эффективное управление пространством и быстрым восстановлением.
			- XFS
   				- журналируемая
   				- Максимальный размер раздела: 8 ЭБ.
				- Максимальный размер файла: 8 ЭБ.
				- Максимальное количество файлов: 2^64.
				- Максимальная длина имени: 256 символов.
				- Количество вложенных каталогов: не ограничено
			- Btrfs
				- журналируемая
				- Максимальный размер раздела: 16 ЭБ.
				- Максимальный размер файла: 16 ЭБ.
				- Максимальное количество файлов: 2^64.
				- Максимальная длина имени: 256 символов.
				- Количество вложенных каталогов: не ограничено.
	   		- Файловые системы Windows
		 		- FAT, FAT32, exFAT, NTFS, ReFS
		   		- Все файловые системы, доступные в операционной системе Windows, состоят из  Файлов, Каталогов, Томов
			- FAT16 (File Allocation Table):
   				- не журналируется
   				- отслеживает объекты файловой системы, используя таблицу уровней томов
	   			- Пространство тома делится на кластеры одинакового размера. В каталоге для каждого файла указывается только номер первого кластера с данными и размер файла.
				- Максимальный размер раздела до 4 ГБ.
				- Максимальный размер файла до 2 ГБ.
			- FAT32
				- создает для каждого файла запись, состоящую из 32 бит вместо прежних 16
				- Максимальный размер раздела до 32 ГБ.
				- Максимальный размер файла до 4 ГБ.
				- exFAT — это файловая система, разработанная для флэш-накопителей
				- Максимальный размер раздела до 128 ПетаБ (10^15).
				- Максимальный размер файла до 128 ПБ.
			- NTFS (New Technology File System):
				- списки управления доступом, журналирование, шифрование, сжатие файлов.
			- ReFS
				- расширение NTFS
				- повышенная устойчивость к повреждению данных
				- поддержка больших размеров файлов и томов
			 	- не поддерживает сжатие и шифрование уровня файлов
	- Файлы и директории
		- Linux:
    		- Файлы - последовательность байтов произвольной длины, содержащая произвольную информацию.
				- Не проводится различия между текстовыми/бинарными/другими файлами.
				- Имена файлов ограничены 255 символами, нельзя использовать NULL.
				- Принято использовать расширения, но не обязательно для системы.
  			- Каталоги - группируют файлы для удобной организации.
               	- хранятся на диске в виде файлов
            	- могут содержать подкаталоги
        		- Иерархическая структура, корневой каталог - /.
				- Задание имени файла: абсолютный путь (от /) ; относительный путь (относительно рабочего каталога).
				- Рабочий каталог - каталог, в котором пользователи или процессы работают в данный момент
				- Ссылки (link) представляют собой записи каталога, указывающие на существующие файлы. Бывают жесткие (hard) (создают новый файл, ссылающийся на тот же inode) и символьные (просто ссылки на inode)
				- При создании каталога в нем автоматически создаются две записи, «.» и «..». Первая запись обозначает сам каталог. Вторая является ссылкой на родительский каталог, то есть каталог, в котором данный каталог числится как запись
				- Точка . в начале имени файла делает его скрытым (нет в ls,  если только не с -a/--all)
    			- Домашний каталог (домашняя папка, домашняя директория) – предназначен для хранения собственных данных пользователя Linux и личных настроек для программ. Переменная $HOME = директория /home/user1/ = ~/
		 - Windows:
			- XD (у лекцыі толькі пра лінух, але хіба вам ФС мала?)
	- Управление внешней памятью.
 		- NFS (<strike>Need for Speed</strike> Network File System):
			- В основе файловой системы NFS лежит представление о том, что пользоваться общей файловой системой может произвольный набор клиентов и серверов.
			- Клиенты и серверы могут быть в одной локальной сети или работать удаленно через Глобальную сеть.
			- Экспорт и Монтирование:
   				- Каждый сервер NFS экспортирует 1+ каталогов, предоставляя доступ удалённым клиентам к нему (и, как правило, подкатлогам).
				- Файл /etc/exports хранит список экспортируемых каталогов для автоматического экспорта при загрузке сервера.
				- Клиенты монтируют удаленные каталоги, интегрируя их в свою файловую систему (по сути как подкаталоги).
				- У файлов могут быть разные имена на различных клиентах из-за разных точек монтирования (то есть путь к ним разный, не собственно имя).
				- Точка монтирования - локальная для клиента, сервер не знает о ее местоположении.
			- NFS поддерживает большинство системных вызовов Linux, за исключением open и close: вместо open - lookup обращается за описателем нужного файла, read содержит описатель файла, смещение, сколько байтов читать; закрывать ничего не надо (ничто не открыто)
			- Нет необходимости хранить информацию об открытых соединениях на сервере.
			- Сбой с перезагрузкой сервера не приводят к потере информации об открытых файлах ("Да потому что у тебя их нет!").
			- Серверы, не поддерживающие информацию состояния открытых файлов, называются серверами без состояния (stateless).
	- ура, канец грэбанага пытаньня... я абавязкова выжыву

22. Принципы организации и структура ОС Windows. Обзор версий Windows. Методы инсталляции ОС Windows.
	- Принципы организации и структура Windows
		- Архитектура шиндовс ![Архитектура](22.1.png)
			- **Ядро операционной системы**. На самом низком уровне операционной системы ядро операционной системы состоит из самого ядра Windows и драйверов устройств низкого уровня. Ядро отвечает за прием запросов операционной системы от системных служб. Затем ядро преобразует эти запросы в инструкции для аппаратного обеспечения компьютера, включая центральный процессор (ЦП), память и аппаратные устройства. При запуске операционной системы сначала инициализируются ядро и связанные с ним низкоуровневые драйверы устройств, а затем службы операционной системы.
			- **Системные службы**. Службы операционной системы являются частью операционной системы, а не компонентами, которые вы устанавливаете после развертывания операционной системы. Кроме того, службы операционной системы функционируют без каких-либо действий со стороны пользователя. Фактически они начинаются до того, как пользователь войдет в систему. И службы операционной системы, и драйверы устройств являются программным обеспечением. Однако разница между ними заключается в том, что драйверы устройств напрямую взаимодействуют с аппаратными устройствами или компонентами. Как правило, системная служба взаимодействует с другими программными компонентами операционной системы
			- **Понимание приложений**. На верхнем уровне операционной системы приложения работают путем взаимодействия с пользователем компьютера, а на нижнем уровне — путем интеграции со службами операционной системы
			- **Отличия службы от приложения**. Служба – процесс, работающий, даже когда никто не зарегистрирован в системе.
			- **Сравнение служб и драйверов**. Информация о службах и драйверах хранится в одном и том же разделе реестра. Различить их можно по параметрам Start и Type
			- **Реестр Windows**. Реестр — это база данных, в которой Windows хранит параметры конфигурации пользователя и компьютера. Всякий раз, когда вы вносите изменения в конфигурацию Windows, это изменение фиксируется в реестре. Реестр Windows организован иерархически
	- Обзор версий Windows
		- Версии шиндовс ![22.2](22.2.png)
	- Методы инсталляции ОС Windows
		- **Ручная установка с использованием установочного носителя:** Применяется, когда нет подходящего образа для конкретной аппаратной платформы или при небольшом количестве установок.
		- **Автономная (необслуживаемая) установка:** Используется файл ответов, предоставляющий ответы на вопросы, задаваемые во время ручной установки. Позволяет автоматизировать установку с заданными параметрами.
		- **Установка, сопровождаемая производителем:** Некоторые производители поставляют носители автономной установки, упрощающие процесс для конечного пользователя.
		- **Создание копий или образов систем:** Полезно при развертывании нескольких идентичных компьютеров или серверов. Создание образов системы с помощью инструментов Microsoft, таких как WDS, Sysprep, или сторонних разработчиков.
		- **Служба развертывания Windows (WDS):** Позволяет развертывать установочные образы и специально настроенные образы на серверах и настольных компьютерах.
		- **Диспетчер настроек системного центра (SCCM):** Средство развертывания и управления образами систем с возможностью централизованного управления.
		- **Инструментальный набор развертывания Microsoft (MDT):** Обеспечивает средства для создания образов, управления драйверами и приложениями, а также автоматизации процесса развертывания

23. ОС Windows: организация рабочей среды пользователя, работа с учетными записями пользователей и групп, работа с профилями пользователей. 
	- Организация рабочей среды пользователя
		- Рабочая среда пользователя состоит из настроек рабочего стола, например, цвета экрана, настроек мыши, размера и расположения окон, из настроек процесса обмена информацией по сети и с устройством печати, переменных среды, параметров реестра и набора доступных приложений.
		- Для управления средой пользователя предназначены следующие средства Windows:
    		- Сценарий входа в сеть (сценарий регистрации) - командный файл .bat или исполняемый файл .ехе, который выполняется при каждой регистрации пользователя в сети.
        	- Профили пользователей, где хранятся все настройки рабочей среды компьютера [, на котором работает Windows 2000], определенные самим пользователем (настройки экрана, соединения с сетью)
			- сервер сценариев Windows (Windows Scripting Host, WSH): предназначен для выполнения сценариев на JScript (не JS!), VBScript (и др.) прямо на рабочем столе Windows или на консоли команд
		  	- и другие средства.
    	- Большинство настроек рабочей среды пользователя можно настроить с помощью групповых политик.
	- Работа с учетными записями пользователей и групп
        - Локальные учетные записи пользователей — это субъекты безопасности, которые используются для защиты и управления доступом к ресурсам на устройстве для служб или пользователей. 
     		- Определяются локально на устройстве и могут назначаться только на этом устройстве.
		- Учетные записи локальных пользователей по умолчанию — это встроенные учетные записи, которые создаются автоматически при установке операционной системы. 
  			- Используются для управления доступом к ресурсам локального устройства на основе прав и разрешений, назначенных учетной записи.
	 			- Учетные записи локальных пользователей по умолчанию и создаваемые локальные учетные записи пользователей находятся в папке Пользователи
		- Учетная запись локального администратора по умолчанию — это учетная запись пользователя для системного администрирования.
  			- первая учетная запись, которая создается при установке Windows.
    		- имеет полный контроль над файлами, каталогами, службами и другими ресурсами на локальном устройстве. 
	 		- может создавать других локальных пользователей, назначать права пользователей и назначать разрешения. 
			- может в любое время управлять локальными ресурсами, изменив права и разрешения пользователя. 
   			- нельзя удалить или заблокировать, но ее можно переименовать или отключить.
	  		- Участники групп "Администраторы" могут запускать приложения с повышенными разрешениями, не используя параметр Запуск от имени администратора. По умолчанию учетная запись администратора входит в группу Администраторы.
	  		- Программа установки Windows отключает встроенную учетную запись администратора и создает другую локальную учетную запись, которая является членом группы администраторов.
		- Гостевая учетная запись позволяет случайным или разовым пользователям, у которых нет учетной записи на компьютере, временно войти на локальный сервер или клиентский компьютер с ограниченными правами пользователя.
  			- По умолчанию учетная запись гостя отключена и имеет пустой пароль.
			- По умолчанию учетная запись "Гость" является единственным членом группы "Гости".
   		- Управление учётной записью локального пользователя
	 		- Учетные записи локальных пользователей по умолчанию и созданные вами учетные записи локальных пользователей находятся в папке «Пользователи».
	   		- Вы можете использовать локальные пользователи и группы для назначения прав и разрешений только на локальном сервере, чтобы ограничить возможность локальных пользователей и групп выполнять определенные действия.
	   		- Разрешение на доступ — это правило, связанное с объектом, регулирующее, какие пользователи могут иметь доступ к объекту на сервере и каким образом.
	   		- Вы также можете управлять локальными пользователями с помощью NET.EXE USER и управлять локальными группами с помощью NET.EXE LOCALGROUP или с помощью различных командлетов PowerShell и других технологий сценариев.
	   		- Применение ограничений локальной учётной записи
		 		- Контроль учетных записей (UAC) — это функция безопасности, которая информирует вас о том, что программа вносит изменения, требующие административных разрешений.
		   		- UAC работает путем настройки уровня разрешений учетной записи пользователя
		   		- UAC может потребовать от администраторов специального одобрения приложений, вносящих общесистемные изменения, прежде чем этим приложениям будет предоставлено разрешение на запуск.
			 	- Учётные записи для служб
			  		- Учетная запись SYSTEM используется операционной системой и службами, работающими под управлением Windows. Это внутренняя учетная запись, которая не отображается в диспетчере пользователей и не может быть добавлена ни в какие группы.
					- Учетная запись NETWORK SERVICE — это предопределенная локальная учетная запись, используемая диспетчером управления службами (SCM). Служба, работающая в контексте учетной записи NETWORK SERVICE, предоставляет учетные данные компьютера удаленным серверам.
				 	- Учетная запись LOCAL SERVICE — это предопределенная локальная учетная запись, используемая диспетчером управления службами. Она имеет минимальные привилегии на локальном компьютере и предоставляет анонимные учетные данные в сети.
	- Работа с профилями пользователей
		- Система создает профиль пользователя при первом входе пользователя на компьютер. При последующих входах система загружает профиль пользователя, а затем другие системные компоненты настраивают среду пользователя в соответствии с информацией в профиле
		- Типы профилей пользователей:
			- Локальные профили: создаётся при первом входе пользователя на компьютер; хранится на локальном жестком диске компьютера.
			- Перемещаемые профили: копия локального профиля, которая копируется в общую папку сервера и хранится в ней. Этот профиль загружается на любой компьютер, на который пользователь входит в сеть. > Пользователям не нужно создавать профиль на каждом компьютере, который они используют в сети.
			- Обязательные профили: это особый тип предварительно настроенного перемещаемого профиля пользователя, который администраторы могут использовать для указания параметров для пользователей. С помощью обязательных профилей пользователей пользователь может изменять свой рабочий стол, но изменения не сохраняются при выходе пользователя из системы. Только системные администраторы могут вносить изменения в обязательные профили пользователей.
			- Временные профили: Выдаются при ошибке загрузки профиля, удаляются после каждого сеанса; изменения, внесенные пользователем в параметры рабочего стола и файлы, теряются при выходе пользователя из системы. 
		- Элементы профиля пользователя:
			- Куст реестра: файл NTuser.dat. Куст загружается системой при входе пользователя и сопоставляется с разделом реестра HKEY_CURRENT_USER. Куст реестра пользователя поддерживает настройки и конфигурацию на основе реестра.
   			- Набор папок профилей, хранящихся в файловой системе. Файлы профилей пользователей хранятся в каталоге Profiles в папке для каждого пользователя.
	  				- Папка профиля пользователя — это контейнер для приложений и других системных компонентов для заполнения вложенными папками и данными для каждого пользователя, такими как документы и файлы конфигурации
		- Преимущества профилей пользователей:
			- Сохранение параметров между входами пользователя.
			- Настроенный рабочий стол для каждого пользователя при совместном использовании компьютера.
			- Уникальность параметров в профиле для каждого пользователя. Изменения в профиле одного пользователя не влияют на других пользователей.

24. Системный реестр ОС Windows, его назначение и использование. 
	- Реестр Windows организован иерархически. На верхнем уровне имеется пять кустов реестра, которые представляют собой отдельный набор связанных параметров, структурированных как серия ключей, подразделов и значений
		- HKEY_CLASSES_ROOT: Ассоциации файлов и приложений для открытия файлов.
		- HKEY_CURRENT_USER (HKCU): Информация о конфигурации текущего пользователя.
		- HKEY_LOCAL_MACHINE (HKLM): Важные параметры конфигурации компьютера.
		- HKEY_USERS: Информация о конфигурации всех пользователей, включая текущего.
		- HKEY_CURRENT_CONFIG: Информация о текущем профиле оборудования.
  	- Для поддержания структуры базы данных аналогичные настройки хранятся в папках и подпапках, известных как ключи и подразделы. Это упрощает ссылку на определенное значение реестра. Вы можете указать путь, объявив соответствующий куст, ключ, подразделы и значение
  	- Типы значений
		- REG_BINARY. Необработанные двоичные данные. Эти значения обычно отображаются в шестнадцатеричном формате. Информация об оборудовании часто хранится в значениях REG_BINARY.
		- REG_DWORD. 4-байтовые числа (32-битное целое число). Многие значения, связанные с драйверами устройств и службами, хранятся в значениях REG_DWORD. Например, значения START и TYPE для драйверов устройств всегда определяются в значениях типа REG_DWORD.
		- REG_SZ. Текстовая строка фиксированной длины.
		- REG_EXPAND_SZ. Текстовая строка переменной длины.
		- REG_MULTI_SZ. Несколько строковых значений.

25. ОС Windows: планирование и назначение разрешений NTFS.
	- NTFS (New Technology File System) - файловая система, используемая в операционных системах Windows.
 	- Разрешения NTFS
		- Разрешения NTFS определяют доступ к файлам и папкам на уровне файловой системы.
		- Разрешения определяют, кто может что делать с файлами и папками (чтение, запись, исполнение).
  		- Информация обо всех объектах файловой системы NTFS, расположенных на томе, хранится в главной таблице файлов (Master File Table, MFT). Каждому файлу или папке соответствует запись в MFT, в которой содержится специальный дескриптор безопасности (Security Descriptor). Дескриптор безопасности включает в себя два списка ACL:
			- System Access Control List (SACL) — системный список контроля доступа. Используется в основном для аудита доступа к объектам файловой системы;
			- Discretionary Access Control List (DACL) — дискретный (избирательный) список контроля доступа. Именно этот список формирует разрешения файловой системы, с помощью которых происходит управление доступом к объекту. В дальнейшем говоря ACL мы будем иметь в виду именно DACL.
		- Каждый список ACL содержит в себе набор записей контроля доступа (Access Control Entry, ACE).
		- При входе пользователя в систему подсистема безопасности собирает данные о его учетной записи и формирует маркер доступа (access token). Маркер содержит идентификатор (SID) пользователя и идентификаторы всех групп (как локальных, так и доменных), в которые пользователь входит. И когда пользователь запрашивает доступ к объекту, информация из маркера доступа сравнивается с ACL объекта и на основании полученной информации пользователь получает (или не получает) требуемый доступ.
		- Разрешения могут быть назначены пользователям или группам пользователей. Группы упрощают управление, так как разрешения могут быть назначены целой группе.
	- Планирование (принципы)
 		- Для упрощения процесса администрирования сгруппируйте файлы по папкам следующих типов: папки с приложениями, папки с данными, личные папки.
   		-  Централизуйте общедоступные и личные папки на отдельном томе, не содержащем файлов ОС и других приложений
	 		-  Устанавливайте для пользователей только необходимый уровень доступа
	   		-  Создавайте группы согласно необходимому членам группы типа доступа, затем установите соответствующие разрешения для группы
		 	-  При установке разрешений для работы с данными или файлами приложений установите разрешение Чтение и выполнение для групп Пользователи и Администраторы. Это предотвратит случайное удаление файлов приложений или их повреждение вирусами или пользователями.
		  	-  При установке разрешений для папок с общими данными назначьте разрешения Чтение и выполнение и Запись группе Пользователи и разрешение Полный доступ для группы Создатель-владелец.
		   	- Запрещайте разрешения, только если необходимо запретить отдельный тип доступа определенному пользователю или группе.
	- Назначение разрешений
 		- Настройка 
			- Выбор Объекта: Выберите файл или папку, для которой вы хотите настроить разрешения.
			- Свойства и Закладка "Безопасность": Правый клик по объекту, выберите "Свойства" и перейдите на закладку "Безопасность".
			- Выбор Пользователя или Группы: Нажмите "Изменить" и выберите нужного пользователя или группу.
		- Основные разрешения
  			- Чтение (Read): Разрешается просматривать вложенные папки и файлы, а также их свойства: имя владельца, разрешения и атрибуты (такие как «только чтение», «скрытый», «архивный» и «системный»)
			- Запись (Write): Разрешается создавать и размещать внутри папки новые файлы и подпапки, а также изменять атрибуты папки и просматривать ее свойства: владельца и разрешения
   			- Список содержимого папки (List Folder Contents): Дает право просматривать имена содержащихся в папке файлов и вложенных подпапок
			- Чтение и выполнение (Read & Execute): Позволяет получить доступ к файлам в подпапках, даже если нет доступа к самой папке. Кроме того, разрешает те же действия, что предусмотрены для разрешений «Чтение» и «Список содержимого папки»
   			- Изменение (Modify): Разрешает все действия, предусмотренные для разрешений «Чтение» и «Чтение и выполнение» + разрешает удаление папки
			- Полный доступ (Full Control): Предоставляет полный доступ к папке. Это значит, что допускаются все действия, предусмотренные всеми перечисленными выше разрешениями. Дополнительно позволяется становиться владельцем папки и изменять ее разрешения
   			- Особые разрешения (Special Permission): Задает набор специальных разрешений, отличающийся от стандартных

26. Средства автоматической настройки в ОС Windows.
	- Командное консольное окно и PowerShell.
		- В Windows есть две оболочки командной строки: командная оболочка cmd и PowerShell. 
		- Каждая оболочка — это программная программа, которая обеспечивает прямую связь между оператором и операционной системой или приложением, предоставляя среду для автоматизации ИТ-операций
		- PowerShell был разработан для расширения возможностей командной оболочки для выполнения команд PowerShell, называемых командлетами. Командлеты похожи на команды Windows, но предоставляют более расширяемый язык сценариев
		- PowerShell может всё, что может cmd, но не наоборот
	- BAT-файлы.
		- BAT-файл (Batch-файл)текстовый файл, содержащий команды системы, которые могут выполняться последовательно. Расширение .cmd или .bat
		- Для вызова другого скрипта используется команда call
		- Для создания переменной используется команда set 
		- 
	- WMI.
		- Инструментарий управления Windows (WMI) — это инфраструктура для управления данными и операциями в операционных системах Windows
		- В основе структуры данных в WBEM лежит Common Information Model (CIM),  реализующая ООП-подход к представлению компонентов системы.
		- wbemtest.exe — графическая утилита для взаимодействия со структурой WMI на локальном или удаленном компьютере.
		- wmic.exe — консольная утилита для взаимодействия со структурой WMI на локальном или удаленном компьютере
	- ETW.
		- служба, которая позволяет получать события от одного или нескольких поставщиков событий в режиме реального времени или из файла *.etl за некоторый временной период. Архитектура ETW включает в себя 4 элемента (рис. 4.2.1):
			- поставщики событий (providers)
			- потребители событий (consumers)
			- контроллеры ETW (controllers)
			- сессии ETW (event tracing sessions)
	  	- ![24.1](24.1.png)
	- Групповые политики.
		- важный элемент любой среды Microsoft Active Directory (AD). Её основная цель — дать ИТ-администраторам возможность централизованно управлять пользователями и компьютерами в домене. Групповая политика состоит из набора политик, называемых объектами групповой политики (GPO). Автоматически создаются два объекта:
    		- политика домена (параметры для всех пользователей и компьютеров домена относительно паролей и блокировки учётных записей)
    		- политика контроллеров домена
  		- Для вступления в силу политика должна быть связана с одним или несколькими контейнерами Active Directory:
    		- сайт
    		- домен
    		- подразделение
  		- С контейнером, очевидно, может быть связано несколько политик
  		- В случае конфликта политик они работают в зависимости от приоритета контейнера (от высшего к низшему):
    		- подразделение
    		- домен
    		- сайт
    		- локальный
  		- В эту последовательность можно вмешаться следующими способами:
    		- Изменение порядка обработки GPO (group policy object). Созданный позднее объект обрабатывается последним и имеет высший приоритет
    		- Блокирование наследования GPO дочерними объектами
    		- Принудительное игнорирование связи GPO. По умолчанию параметры родительских политик перезаписываются любыми конфликтующими политиками дочерних объектов
    		- Отключение GPO. Можно отключить применение конкретного GPO для конкретного контейнера
	- Административные шаблоны.
		- в формате XML, написанные на различных языках, которые задают параметры групповых политик, основанные на значениях реестра. Эти параметры отображаются и редактируются в локальном редакторе групповых политик на компьютере
		- Представляют собой иерархическую структуру категорий и подкатегорий политики, которые определяют, каким образом параметры политики отображаются в редакторе локальных групповых политик
    		- расположение каждого параметра в реестре
    		- возможные значения и ограничения каждого параметра
    		- значение по умолчанию для каждого параметра
    		- текстовые пояснения каждого параметра
		- Виды шаблонов
    		- ADMX (не зависит от языка, указывает количество и тип параметров политики)
    		- ADML (файл установки на определённом языке, предоставляет связанные с языком сведения для ADMX-файла)
  	- В doc-файле там ещё пункты были, но я не совсем понял, как они относятся к автоматической настройке шиндовс, так что убрал их

27. Основные понятия системы UNIX. Пользователи системы, атрибуты пользователя. Файловая структура ОС. 
	- Основные понятия системы UNIX
 		- Существует два основных объекта операционной системы UNIX, с которыми приходится работать пользователю – файлы и процессы.
   		- Все данные пользователя хранятся в файлах; доступ к периферийным устройствам осуществляется посредством чтения и записи специальных файлов; во время выполнения программы, операционная система считывает исполняемый код из файла в память и передает ему управление.
		- С другой стороны, вся функциональность операционной системы определяется выполнением соответствующих процессов. В частности, обращение к файлам на диске невозможно, если файловая подсистема операционной системы (совокупность процессов, осуществляющих доступ к файлам) не имеет необходимого для этого кода в памяти.
		- Операционная система UNIX организована как пирамида, где аппаратное обеспечение находится в основании, а операционная система управляет аппаратурой и предоставляет интерфейс системных вызовов для программ. Программы используют системные вызовы для создания и управления процессами, файлами и другими ресурсами.
  			- Пользователи
	 			- /интерфейс пользователя 
	 			- Стандартные обслуживающие программы (оболочка, компиляторы...) [режим пользователя]
				- /интерфейс библиотечных функций
				- Стандартная библиотека (open, close, read, write, fork...) [режим пользователя]
		  		- /интерфейс системных вызовов
		  		- Операционная система UNIX (управление процессами, памятью, ФС, I/O...) [режим ядра]
				- Аппаратное обеспечение (ЦП, память, диски, терминалы...)
		- Операционная система включает стандартные программы, такие как командный процессор, компиляторы, редакторы, программы обработки текста, утилиты для работы с файлами.
		- Графический интерфейс пользователя основан на оконной системе X [Windowing System], которая управляет визуальным представлением на экране.
	- Пользователи системы
		- Прежде чем клиент сможет начать работу с ОС UNIX, он должен стать пользователем системы, т.е. получить имя, пароль и ряд других атрибутов. Пользователем является объект, который обладает определенными правами и может запускать на выполнение программы и владеть файлами. Пользователями могут быть отдельные клиенты, удаленные компьютеры или группы пользователей с одинаковыми правами и функциями. В системе существует один пользователь, обладающий неограниченными правами - это суперпользователь или администратор системы (обычно с именем root).
		- Система различает пользователей по идентификатору пользователя UID.
		- Группа — список пользователей, имеющих сходные задачи. Каждая группа имеет уникальное имя, а система различает группы по групповому идентификатору (GID).
  		- Информация о пользователях обычно хранится в специальном файле: /etc/passwd, о группах — /etc/group.
  		- Идентификатор пользователя и идентификатор группы определяет, какими правами обладает пользователь в системе.
		- Все атрибуты пользователя хранятся в файле /etc/passwd
  	- Атрибуты пользователя
   		- Как правило, все атрибуты пользователя хранятся в файле /etc/passwd
		- Каждая строка файла является записью конкретного пользователя и имеет следующий формат: name:passwd-encod:UID:GID:comments:home-dir:shell
			- name: Регистрационное имя пользователя, используемое при входе в систему.
			- passwd-encod: Закодированный пароль пользователя. Алгоритм кодирования предотвращает декодирование пароля. В некоторых системах пароль хранится в отдельном файле, а в поле passwd-encod может быть символ 'х' или '!'.
			- UID: Идентификатор пользователя, внутреннее представление пользователя в системе. Суперпользователь имеет UID=0 (неограниченные права).
			- GID: Идентификатор первичной группы пользователя, соответствует идентификатору в файле /etc/group.
   			- comments: Полное "реальное" имя пользователя, может содержать дополнительную информацию (телефон, email).
			- home-dir: Домашний каталог пользователя, где пользователь оказывается при входе в систему.
			- shell: Имя программы, используемой в качестве командного интерпретатора, запускается при входе в систему. Обычно это /bin/sh, /bin/csh или /bin/ksh. Завершив выполнение этой задачи, пользователь автоматически выйдет из системы.
	- Файловая структура ОС
		- В начале развития Linux использовалась файловая система MINIX 1, но ограничения по длине имен (14) и размеру (64МБ) файлов привели к разработке улучшенной файловой системы ext (имена: 255 символов, размер: 2ГБ). Затем появилась ФС ext2, ставшая основной для Linux.
  		- Linux поддерживает несколько десятков файловых систем при помощи уровня виртуальной файловой системы Virtual File System (VFS)
		- Файл в системе Linux — это последовательность байтов произвольной длины (от 0 до некоторого максимума), содержащая произвольную информацию. 
		- Не делается различия между текстовыми/двоичными/другими файлами. Значение битов в файле целиком определяется владельцем файла. Имена файлов ограничены 255 символами. В именах файлов разрешается использовать все ASCII-символы, кроме символа NULL.
		- Для удобства файлы могут группироваться в каталоги. Каталоги хранятся на диске в виде файлов. Каталоги могут содержать подкаталоги, что приводит к иерархической файловой системе. Корневой каталог называется / 
 		- Важные каталоги:
   			- bin: Двоичные (исполняемые) программы
	  		- dev: Специальные файлы для устройств ввода-вывода
		 	- etc: Разные системные файлы
		   	- lib: Библиотеки
			- usr: Каталоги пользователей
		- Существует два способа указания имени файла в системе Linux: абсолютный путь, начинающийся от /, и относительный путь, указывающий относительно рабочего каталога.
  		- Кроме обычных файлов Linux поддерживает также символьные специальные файлы и блочные специальные файлы:
			- Символьные специальные файлы используются для моделирования последовательных устройств ввода-вывода, таких как клавиатуры и принтеры.
			- Блочные специальные файлы (обычно с такими именами, как /dev/hd1) могут использоваться для чтения и записи необработанных (raw) дисковых разделов, минуя файловую систему.
		- Для безопасного совместного доступа к файлам стандарт POSIX предоставляет гибкий механизм блокировки файлов, позволяя процессам блокировать как единичные байты, так и целые файлы за одну неделимую операцию. Стандарт определяет два типа блокировок: с монополизацией (эксклюзивные) и без монополизации (общие).
  			- Если часть файла имеет блокировку без монополизации, то можно повторно установить такую же блокировку, но блокировка с монополизацией будет отвергнута.
	 		- Если область файла заблокирована с монополизацией, то любые попытки блокировки этой области будут отвергнуты до снятия блокировки.
		- Файлы ядра можно обнаружить в каталоге /boot.
  		- Одна из наиболее распространенных директорий для установки программ — это /usr/bin (содержит исполняемые файлы программ, доступные для всех)
			- /opt служит для установки приложений, которые не являются частью основной операционной системы.
	  		- В /usr/local обычно размещаются локально установленные программы.

28. ОС UNIX: особенности процессов, сигналы, обработка сигналов.  
	- Особенности процессов
		- Основными активными сущностями в системе Linux являются процессы. Каждый процесс выполняет одну программу и изначально получает один поток управления. Иначе говоря, у процесса есть один счетчик команд, который отслеживает следующую исполняемую команду. Linux позволяет процессу создавать дополнительные потоки (после того, как он начинает выполнение).
		- Системный вызов fork создает точную копию исходного процесса, называемого родительским процессом (parent process). У родительского и у дочернего процессов есть собственные (приватные) образы памяти. Если родительский процесс впоследствии изменяет какие-либо свои переменные, то эти изменения остаются невидимыми для дочернего процесса (и наоборот).
		- fork возвращает дочернему процессу число 0, а родительскому — отличный от нуля PID дочернего процесса. getpid
		- Типы процессов
			- Системные процессы - часть ядра, всегда в оперативной памяти. Не имеют соответствующих исполняемых файлов, запускаются особым образом при инициализации ядра. Примеры: shed, vhand, bdfflush, kmadaemon, и init. 
			- Демоны (daemons) фоновые процессы, работающие в фоновом режиме и обслуживающие различные системные задачи или услуги. Они часто запускаются при загрузке системы и работают независимо от активности конкретного пользователя. Типичным демоном является cron. Он просыпается раз в минуту, проверяя, не нужно ли ему что-то сделать. Есть работа-выполняет, нету-спит до след проверки. Позволяет планировать в системе Linux активность на минуты, часы, дни и месяцы вперед.
			- Прикладные процессы - все остальные, выполняющиеся в системе, часто порождаемые пользовательским сеансом. Пример: команды, запущенные пользователем. Время их выполнения ограничено сеансом работы
	- Сигналы - это способ информирования процесса со стороны ядра о происшествии некоторого события. Один процесс может посылать сигнал другому через системный вызов kill. 
	- Обработка сигналов
		- осуществляется через установку обработчиков сигналов. Когда процесс получает сигнал, ядро отправляет управление к обработчику, который был предварительно установлен для этого сигнала. Процесс может выбрать различные действия при получении сигнала:
			- Игнорирование (SIG_IGN): Процесс может проигнорировать сигнал, если установлен обработчик SIG_IGN (ignore). 
			- По умолчанию (SIG_DFL): Если не установлен пользовательский обработчик, применяется действие по умолчанию (default). Например, завершение процесса.
			- Пользовательский обработчик (функция): Процесс может установить свою собственную функцию-обработчик. Когда сигнал поступает, управление передается этой функции.

29. Основные принципы функционирования Linux. Основные компоненты Linux. Дистрибутивы Linux. Файловая система Linux. 
	- Основные принципы функционирования Linux
		- Linux имеет низкие аппаратные требования в текстовом режиме, что позволяет работать на машинах с 486 процессором и 16 MB RAM.  Организация программно-аппаратных средств во всех UNIX-совместимых системах организована по принципу клиент-сервер.
  		- Пользователи работают через виртуальные терминалы, переключаясь по Alt + F1...F12. Один компьютер может одновременно выполнять роль и сервера сети, и рабочей станции.
			- В ОС Linux все файлы организованы в непрерывный поток байтов. Данные, вводимые с клавиатуры, представляют собой входной поток данных, а отображаемые данные – выходной поток. В данной ОС широко используется переадресация (cat, >, >>, <).
	  		- Для передачи данных из одной команды в другую используется оператор конвейера | (Пример: $ ls | lpr)
			- В ОС Linux имена файлов могут содержать любые буквы, знаки подчеркивания и цифры. Но не должно начинаться с цифры, точки (кроме скрытых системных файлов) или содержать знаки /, \,?, *. Максимальная длина имени – 256 символов.
			- Файл может быть каталогом или исполняемой программой (командой).
		- Файловая система в ОС Linux как и в большинстве других систем имеет иерархическую (древовидную) структуру. Вверху дерева всегда находится корневой каталог ROOT.
 	- Основные компоненты
  		- / При загрузке компьютера операционная система Linux перехватывает управление компьютером и управляет его компонентами. В ядре собрана основная функциональность для работы с памятью, управления процессами и т.д. Когда ядру требуется дополнительные функции, оно обращается к модулям. Файлы ядра Linux находятся в /boot. Версию используемого ядра Linux можно узнать c помощью команды uname. 
		- Планировщик: назначает процессам приоритеты и определяет, какой процесс выполняется на конкретном процессоре (если в системе установлено несколько процессоров).
		- Файл подкачки: выделенная область на жестком диске, которая используется для хранения не перемещающихся в оперативную память данных и процессов; При переполнении оперативной памяти процессы выносятся в файл подкачки.
		- Модули: Позволяют динамически добавлять поддержку новых устройств, в работающее ядро включаются только актуальные драйвера.
		- Файловые системы: предоставляют структуры, в которых файлы хранятся на компактдисках, жестких дисках, гибких дисках, DVD и на других носителях. Ядро Linux поддерживает множество (немало) типов файловых систем.
		- Механизмы защиты: Для защиты пользовательских ресурсов каждому файлу назначаются наборы разрешений на чтение, запись и выполнение, которые определяют права доступа.
		- Инструменты администрирования: включают в себя множество (немало) команд и графических утилит, которые позволяют добавлять пользователей, управлять дисками, следить за состоянием сети, устанавливать программное обеспечение, а также гарантировать безопасность и управлять ресурсами компьютера.
		- Сервисные возможности: позволяют компьютеру под управлением Linux предоставлять службы для клиентов в сети. Серверные функции: web-серверы, серверы email, БД, печати, DNS, DHCP, файловые серверы.
		- Графический интерфейс пользователя: состоит из графической инфраструктуры (обычно X WindowSystem), оконных менеджеров, панелей, пиктограмм и меню. Позволяет применять комбинацию мыши и клавиатуры вместо простого ввода команд с клавиатуры.
		- Система управления пакетами: набор инструментов, предназначенных для автоматизации процессов установки, обновления, конфигурирования и удаления пакетов программного обеспечения определенного формата. СУПы: RPM/YUM, APT, tgz, YaST и др.
  	- Дистрибутивы Linux: состоят из отдельных пакетов, каждый из которых содержит какое-то приложение, утилиту или сервис. ПО в пакете посталяется либо как бинарные файлы, либо как <strike>небинарные файлы</strike> заархивированные исходные тексты + вспомогательные файлы для компиляции.
		- Три группы дистрибутивов Linux
			- Enterprise Grade Linux - предназначены для развертывания в крупных организациях с использованием оборудования предприятия. (Red Hat Enterprise Linux, CentOS, SUSE Linux Enterprise Server, Debian GNU/Linux, Ubuntu LTS)
				- Стабильность и долгосрочная поддержка.
				- Ориентированы на надежность и безопасность.
				- Медленное внедрение новых технологий.
				- Предоставляют более старые, но стабильные версии программного обеспечения.
			- Consumer Grade Linux - больше ориентированы на малый бизнес или домашних пользователей и любителей. (Fedora, Ubuntu non-LTS, openSUSE)
				- Ориентированы на новое оборудование и современные драйверы.
				- Регулярные выпуски с обновлениями.
				- Более быстрое внедрение новых технологий.
			- Experimental and Hacker Linux - используют самые современные технологии. (Arch, Gentoo)
				- Использование самых последних технологий.
				- Скользящая модель выпуска (обновления доставляются в любое время).
				- Предоставляют возможность для тестирования будущих функций.
				- Разработаны для пользователей, готовых к возможным проблемам и изменениям.
	- ФС Linux
		- Файловая система в ОС Linux как и в большинстве других систем имеет иерархическую (древовидную) структуру. Все объекты являются файлами, в том числе и директории для организации доступа к файлам. 
		- Существуют следующие типы файлов: обычные файлы, каталоги, символьные ссылки, блочные устройства, символьные устройства, сокеты, каналы.
		- Всегда есть только один корневой каталог, который называется /
		- Абсолютные (от корня /) и относительные (от рабочего каталога .) пути, родительская директоия - ..
		- Имя может содержать любые символы, кроме / ? < > * " |
   		- Имена файлов в Linux чувствительны к регистру
   		- Максимальная длина имени файла — 254 символа
		- Точка . в начале имени файла делает его скрытым, то есть, он не показывается в выводе команды ls (нужно -a или --all).
		- Команда pwd (Print Working Directory) возвращает полный путь к текущей директории командной оболочки (хранится в переменной PWD).
   		- Для смены текущей директории используется команда cd (Change Directory)
		- Домашний каталог (домашняя папка, домашняя директория) – предназначен для хранения собственных данных пользователя Linux и личных настроек для программ. Полный путь к домашнему каталогу хранится в переменной окружения HOME, Для обычных пользователей домашний каталог находится в директории /home/user1/, или ~/
		- FHS (Filesystem Hierarchy Standard) – стандарт файловой системы, специфичной для GNU/Linux. В FHS все файлы и каталоги находятся внутри корневого каталога, даже если они расположены на различных физических носителях. В корневой директории должны быть следующие директории:
   			- /bin Основные утилиты, необходимые как в однопользовательском режиме, так и при обычной работе всем пользователям
			- /boot Файлы ядра
			- /dev Файлы устройств
			- /etc Общесистемные конфигурационные файлы
			- /home Содержит домашние папки пользователей. Часто размещается на отдельном разделе
			- /lib Основные библиотеки, необходимые для работы программ из /bin и /sbin
			- /media Точки монтирования для сменных носителей, таких как CD-ROM, DVD-ROM
			- /mnt Содержит временно монтируемые файловые системы
			- /opt Дополнительное прикладное программное обеспечение
			- /proc Виртуальная файловая система, представляющая состояние ядра операционной системы и запущенных процессов в виде файлов
			- /root Домашняя папка пользователя root
			- /run Временные данные выполняющихся процессов
			- /sbin Основные системные программы для администрирования и настройки системы
			- /srv Данные для сервисов, предоставляемых системой
			- /tmp Временные файлы
			- /usr Вторичная иерархия для данных пользователя, содержит большинство пользовательских приложений и утилит, используемых в многопользовательском режиме.
			- /var Изменяемые файлы, такие как файлы регистрации, временные почтовые файлы, файлы спулеров

30. ОС Linux: управление процессами, выполнение задач в фоновом режиме, изменение приоритетов выполняющихся программ. 
	- Управление процессами
		- Процессы существуют в иерархии: после загрузки ядра в память запускается первый процесс (init или systemd), который, в свою очередь, запускает другие процессы, которые, опять же, могут запускать другие процессы.
		-  Каждый раз, когда пользователь вводит команду, запускается программа и генерируется один или несколько процессов. Каждый процесс имеет уникальный идентификатор (PID) и идентификатор родительского процесса (PPID).
		-  Команда ```top``` динамически отображает все запущенные процессы ![28.1](28.1.png) Команды l t m управляют отображением строк статистики. Для сортировки служат команды M (память), N (ID процесса), T (время выполнения), P (процент загрузки процессора). Изменение порядка сортировки – R.
		-  ```ps``` выводит статическую информацию о процессах. Команда поддерживает три стиля параметров, причем они не совпадают. Например, ps aux не эквивалентна ps –aux, но ps -e эквивалентна ps ax
		-  Иерархию процессов команда ```pstree```
		-  Завершить процесс ```kill```
	- Выполнение задач в фоновом режиме
		- Для выполнения команды в фоновом режиме достаточно добавить в конце символ амперсанда &.
		- Работая в фоновом режиме, команда все равно продолжает выводить сообщения в терминал, из которого была запущена. Для этого она использует потоки stdout и stderr, которые можно закрыть при помощи следующего синтаксиса:```$ command >  /dev/null 2>&1 &```
		- Узнать состояние всех остановленных и выполняемых в фоновом режиме задач в рамках текущей сессии терминала можно при помощи утилиты ```jobs -l```.
		- В любое время можно вернуть процесс из фонового режима на передний план ```fg```. Если в фоновом режиме выполняется несколько программ, следует указывать номер. Например: ```$ fg %1```
		- Для завершения фонового процесса применяют команду ```kill``` с номером программы
		- Если изначально процесс был запущен обычным способом, его можно перевести в фоновый режим, выполнив следующие действия:
			- Остановить выполнение команды, нажав комбинацию клавиш Ctrl+Z
			- Перевести процесс в фоновый режим при помощи команды bg
	- Изменение проиритетов выполняющихся программ
		- Утилита nice — программа, предназначенная для запуска процессов с изменённым приоритетом nice.
		- Приоритет nice (целое число) процесса используется планировщиком процессов ядра ОС при распределении процессорного времени между процессам 
		- nice – значение любезности, чем меньше, тем выше приоритет
		- значение nice – минимальное значение приоритета =лучшее значение = самый высокий приоритет.
		- nice – диапазон приоритетов [-20, 19], default = 0;
		- Планировщик процессов ядра ОС Linux поддерживает приоритеты от 0 (реальное время) до 139 включительно. Приоритеты -20…+19 утилиты или команды nice соответствуют приоритетам 100…139 планировщика процессов. Другие приоритеты планировщика процессов можно установить командой chrt из пакета util-linux
		- Чтобы установить значение nice ниже нуля, требуются права суперпользователя

31. Понятие безопасности ОС. Основные угрозы безопасности ОС. Методы и защитные механизмы операционных систем. 
	- Понятие безопасности операционной системы (ОС):
		- Безопасность в контексте операционных систем охватывает механизмы и стратегии, направленные на защиту информации и обеспечение нормальной работы системы. Для разграничения, термин "безопасность" будет использоваться для общих вопросов, а "защитные механизмы" — для конкретных мер, используемых ОС.
		- Задачи
			- конфиденциальность (направлено на сохранение секретности данных)
			- целостность (означает, что пользователи, не обладающие необходимыми правами, не должны иметь возможности изменять какие-либо данные без разрешения их владельцев)
			- доступность (означает, что никто не может нарушить работу системы и вывести ее из строя)
  	- Основные угрозы безопасности ОС
		- Угрозы безопасности
			- незащищённость данных
			- подделка данных
			- отказ от обслуживания
		- Классификация
    		- по цели атаки
				- чтение информации
				- изменение информации
				- уничтожение информации
				- полное или частичное разрушение ОС
			- по принципу воздействия
				- использование известных (легальных) каналов получения информации
				- использование скрытых каналов
				- создание новых каналов с помощью программных закладок
			- по характеру воздействия
				- активное (действия в системе)
				- пассивное (наблюдение в системе)
		- Типичные атаки
			- сканирование файловой системы
			- подбор пароля
				- полный перебор
				- полный перебор, оптимизированный по статистике встречаемости
				- перебор с использованием данных о пользователе
			- кража ключевой информации
			- превышение полномочий (при помощи ошибок в ПО)
			- программные закладки
			- жадные программы (потребляющие чрезмерное количество ресурсов и не дающие работать другим программам)
  	- Методы и защитные механизмы операционных систем
    	- Операционную систему называют защищенной, если она предусматривает средства защиты от основных классов угроз. Защищенная операционная система обязательно должна содержать средства разграничения доступа пользователей к своим ресурсам, а также средства проверки подлинности пользователя, начинающего работу с операционной системой. Кроме того, защищенная операционная система должна содержать средства противодействия случайному или преднамеренному выводу операционной системы из строя
		- Подходы к построению защищённых ОС
			- фрагментарный подход (защитные функции добавляются отдельно после создания системы)
			- комплексный (защитные функции внедряются на этапе проектирования)
		- Основные административные меры защит
    		- постоянный контроль корректности функционирования ОС
    		- организация политики безопасности
    		- осведомление пользователей о необходимости соблюдения мер безопасности
    		- регулярное резервное копирование
    		- постоянный контроль изменений в конфигурации и политике безопасности ОС

32. Механизмы безопасности в операционных системах семейства Windows.
	- Идентификаторы безопасности (SID).
		- Идентификатор безопасности (SID) — это уникальное значение переменной длины, используемое для идентификации доверенного лица. Каждая учетная запись имеет уникальный идентификатор безопасности, выданный центром сертификации. Каждый раз, когда пользователь входит в систему, система получает идентификатор безопасности для этого пользователя из базы данных и помещает его в маркер доступа для этого пользователя
		- API
			- LookupAccountName
			- InitializeSid
			- т.д.
	- Маркеры защиты.
		- Маркер доступа — это объект, описывающий контекст безопасности процесса или потока. Сведения в маркере включают удостоверение и привилегии учетной записи пользователя, связанной с процессом или потоком. Когда пользователь входит в систему, система проверяет пароль пользователя, сравнивая его с информацией, хранящейся в базе данных безопасности. Если пароль прошел проверку подлинности, система создает маркер доступа. Каждый процесс, выполняемый от имени этого пользователя, имеет копию этого маркера доступа
		- Маркеры доступа содержат следующие сведения:
			- Идентификатор безопасности (SID) для учетной записи пользователя
			- Идентификаторы безопасности для групп, членом которых является пользователь
			- Идентификатор безопасности входа, который идентифицирует текущий сеанс входа в систему.
			- Список привилегий, которыми пользовались пользователи или группы пользователей.
			- Идентификатор безопасности владельца
			- Идентификатор безопасности для основной группы и тд
	  	- API
			- OpenProcessToken
			- OpenThreadToken
			- т.д.
	- Списки управления доступом (ACL).
		- Списки управления доступом (ACL) состоят из записей управления доступом (ACE). Каждый ACE в ACL идентифицирует доверенного лица и указывает права доступа, разрешенные, запрещенные или регистрируемые для этого доверенного лица. Дескриптор безопасности для защищаемого объекта может содержать два типа списков управления доступом: DACL и SACL
			- Список управления доступом (DACL) на уровне пользователей определяет, кому разрешен или запрещен доступ к объекту. При запросе доступа система проверяет записи ACE в DACL объекта, определяя, следует ли предоставлять доступ. Если DACL отсутствует, полный доступ предоставляется всем пользователям. Если DACL не содержит соответствующих записей ACE, доступ к объекту отклоняется. Система проверяет ACE последовательно, пока не найдет разрешающую запись или отклонит доступ.
			- Системный список управления доступом (SACL) позволяет регистрировать попытки доступа к объекту, создавая записи аудита в журнале событий безопасности. Каждая запись ACE в SACL указывает типы попыток доступа, которые приведут к созданию записи в журнале событий. SACL может фиксировать попытки доступа при успехе и/или при неудаче.
	- Доменные службы Active Directory.
		- AD является службой каталогов, предоставляющей иерархическую структуру для хранения и предоставления сведений об объектах в сети. В контексте AD DS (Active Directory Domain Services), эта служба хранит информацию о пользователях, группах, серверах и других ресурсах в сети. Администраторы и авторизованные пользователи могут получать доступ к этим данным для управления и использования в сети
		- Active Directory также включает следующие компоненты:
			- Схема — набор правил, который определяет классы объектов и атрибутов, содержащихся в каталоге, и ограничения экземпляров этих объектов, а также формат их имен.
			- Глобальный каталог, содержащий сведения о каждом объекте в каталоге. Это позволяет находить сведения о каталоге независимо от того, какой домен в каталоге фактически содержит данные.
			- Механизм запроса и индекса, чтобы объекты и их свойства могли быть опубликованы и найдены сетевыми пользователями или приложениями.
			- Служба репликации, которая синхронизирует данные каталога по сети. Все контроллеры домена в домене участвуют в репликации и содержат полную копию всех сведений о каталоге для своего домена. Любые изменения данных каталога реплицируются в домене на все контроллеры домена
	  	- Информации просто вагон, как это учить?
	- Виды групп пользователей
		- Группы безопасности. Используйте для назначения разрешений общим ресурсам.
		- Группы рассылки: создание списков рассылки электронной почты.
		Каждая группа имеет область, определяющую степень применения группы в дереве домена или лесу. Область группы определяет, где можно предоставить разрешения сети для группы. 

33. Механизмы безопасности в операционных системах семейства Linux.
	- В Linux у каждого файла и каждого каталога есть два владельца: пользователь и группа. владельцы устанавливаются при создании файла или каталога. Чтобы увидеть текущие назначения владельца, вы можете использовать команду ```ls-l```.  Эта команда показывает пользователя и группу-владельца. Команда chown позволяет сменить владельца (команда chgrp – только группу-владельца).
	![33.1](33.1.png)
	![33.2](33.2.png)
	- Управление разрешениями. Команда chmod позволяет изменять разрешения двумя способами: 
		- символьным ```chmod a+x cat.txt```
		- числовым ```chmod 750 animals```
  	- Некоторые опции:
		- ```-R, --recursive``` изменять файлы и директории рекурсивно
		- ```-v, --verbose``` выводить диагностику о каждом обрабатываемом файле 
		- ```-c, --changes``` выводить диагностику только для изменяемых файлов
	- В операционной системе Linux базовые права для директории равны ```0777``` (rwxrwxrwx), а для файла ```0666``` (rw-rw-rw) По умолчанию ```umask 0002``` используется для обычного пользователя. С этой маской права по умолчанию для директории равны ```775```, а для файла – ```664```.
	- Атрибуты файла — это свойства метаданных, которые описывают поведение файла. Например, атрибут может указывать, сжат ли файл, или указывать, можно ли удалить файл. Вы можете просмотреть атрибуты файла с помощью команды ```lsattr```: ```lsattr todo.txt```
	- Одно из распространенных применений ```chattr``` — установка неизменяемого флага для файла или каталога, чтобы пользователи не могли удалить или переименовать файл.
	- Управление свойствами файлов
		- В Linux каждый файл имеет довольно много свойств, например, права доступа устанавливаются трижды (для владельца, группы и всех прочих), метки времени также бывают трёх разных видов (время создание, доступа и изменения).
		- У каждого файла доступны следующие метки времени:
			- Доступ
			- Модифицирован
			- Изменён
			- Создан
		- Посмотреть метки времени папки можно также с помощью команды ```stat```: ```stat /путь/до/папки```
		- С помощью команды ```touch``` можно изменить три метки времени файла или папки:
			- время доступа
			- время модификации
			- время изменения статуса

